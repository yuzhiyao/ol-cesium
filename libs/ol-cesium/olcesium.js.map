{"version":3,"sources":["webpack://olcs_unused_var/webpack/bootstrap","webpack://olcs_unused_var/external \"ol.proj\"","webpack://olcs_unused_var/external \"ol.Observable\"","webpack://olcs_unused_var/external \"ol.layer.Group\"","webpack://olcs_unused_var/external \"ol.source.Vector\"","webpack://olcs_unused_var/external \"ol.layer.Image\"","webpack://olcs_unused_var/external \"ol.source.Cluster\"","webpack://olcs_unused_var/external \"ol.layer.Vector\"","webpack://olcs_unused_var/external \"ol.geom.Geometry\"","webpack://olcs_unused_var/external \"ol.style.Icon\"","webpack://olcs_unused_var/external \"ol.extent\"","webpack://olcs_unused_var/external \"ol.geom.Point\"","webpack://olcs_unused_var/external \"ol.easing\"","webpack://olcs_unused_var/external \"ol.layer.Tile\"","webpack://olcs_unused_var/external \"ol.source.ImageStatic\"","webpack://olcs_unused_var/external \"ol.source.ImageWMS\"","webpack://olcs_unused_var/external \"ol.source.TileImage\"","webpack://olcs_unused_var/external \"ol.source.TileWMS\"","webpack://olcs_unused_var/external \"ol.source.Image\"","webpack://olcs_unused_var/external \"ol.layer.Layer\"","webpack://olcs_unused_var/external \"ol.layer.VectorTile\"","webpack://olcs_unused_var/external \"ol.geom.Polygon\"","webpack://olcs_unused_var/external \"ol.geom.SimpleGeometry\"","webpack://olcs_unused_var/external \"ol.Overlay\"","webpack://olcs_unused_var/./src/olcs/util.js","webpack://olcs_unused_var/./src/olcs/core/OLImageryProvider.js","webpack://olcs_unused_var/./src/olcs/core.js","webpack://olcs_unused_var/./src/olcs/AutoRenderLoop.js","webpack://olcs_unused_var/./src/olcs/math.js","webpack://olcs_unused_var/./src/olcs/Camera.js","webpack://olcs_unused_var/./src/olcs/AbstractSynchronizer.js","webpack://olcs_unused_var/./src/olcs/RasterSynchronizer.js","webpack://olcs_unused_var/./src/olcs/core/VectorLayerCounterpart.js","webpack://olcs_unused_var/./src/olcs/FeatureConverter.js","webpack://olcs_unused_var/./src/olcs/VectorSynchronizer.js","webpack://olcs_unused_var/./src/olcs/SynchronizedOverlay.js","webpack://olcs_unused_var/./src/olcs/OverlaySynchronizer.js","webpack://olcs_unused_var/./src/olcs/OLCesium.js","webpack://olcs_unused_var/./src/olcs/contrib/LazyLoader.js","webpack://olcs_unused_var/./src/olcs/contrib/Manager.js","webpack://olcs_unused_var/./src/index.library.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ol","proj","Observable","layer","Group","source","Vector","Image","Cluster","geom","Geometry","style","Icon","extent","Point","easing","Tile","ImageStatic","ImageWMS","TileImage","TileWMS","Layer","VectorTile","Polygon","SimpleGeometry","Overlay","util_exports","olcsListen","observable","type","listener","on","obj","param","supportsImageRenderingPixelatedResult_","undefined","imageRenderingValueResult_","supportsImageRenderingPixelated","canvas","document","createElement","setAttribute","tmp","imageRenderingValue","getSourceProjection","getProjection","uidCounter_","getUid","olcs_uid","isGroundPolylinePrimitiveSupported","scene","Cesium","GroundPolylinePrimitive","isSupported","util","OLImageryProvider_OLImageryProvider","[object Object]","olMap","opt_fallbackProj","this","source_","projection_","fallbackProj_","ready_","tilingScheme_","rectangle_","map_","proxy","proxy_","getURL","DefaultProxy","errorEvent_","Event","emptyCanvas_","width","height","e","handleSourceChanged_","frameState","getState","external_ol_proj_","GeographicTilingScheme","WebMercatorTilingScheme","rectangle","x","y","level","getView","calculateExtent","getSize","center","getCenter","viewState","zoom","attributionsFunction","getAttributions","attributions","Array","isArray","map","html","Credit","tileUrlFunction","getTileUrlFunction","z_","y_","url","ImageryProvider","loadImage","defineProperties","ready","tileWidth","tg","getTileGrid","getTileSize","tileHeight","maximumLevel","getMaxZoom","minimumLevel","tilingScheme","tileDiscardPolicy","errorEvent","hasAlphaChannel","pickFeatures","core_OLImageryProvider","core_exports","computePixelSizeAtCoordinate","target","camera","frustum","distance","Cartesian3","magnitude","subtract","position","pixelSize","Cartesian2","getPixelDimensions","clientWidth","clientHeight","computeBoundingBoxAtTarget","amount","transform","Transforms","eastNorthUpToFixedFrame","bottomLeft","Matrix4","multiplyByPoint","topRight","Ellipsoid","WGS84","cartesianArrayToCartographicArray","applyHeightOffsetToGeometry","geometry","applyTransform","input","output","stride","length","createMatrixAtCoordinates","coordinates","rotation","translation","ZERO","scale","ol4326CoordinateToCesiumCartesian","rawMatrix","quaternion","Quaternion","fromAxisAngle","UNIT_Z","rotationMatrix","fromTranslationQuaternionRotationScale","multiply","rotateAroundAxis","angle","axis","opt_options","clamp","Math","defaultValue","options","duration","external_ol_easing_","callback","lastProgress","oldTransform","start","Date","now","step","timestamp","progress","clone","stepAngle","lookAtTransform","rotate","window","requestAnimationFrame","setHeadingUsingBottomCenter","heading","bottomCenter","angleToZenith","computeAngleToZenith","right","Matrix3","fromQuaternion","vector","zenith","multiplyByVector","add","fromTranslation","pickOnTerrainOrEllipsoid","pixel","ray","getPickRay","globe","pick","pickEllipsoid","pickBottomPoint","bottom","pickCenterPoint","computeSignedTiltAngleOnGlobe","Ray","direction","ellipsoid","IntersectionTests","rayEllipsoid","getPoint","normal","geocentricSurfaceNormal","angleBetween","signedAngleBetween","PI","convertLongitudeRange","bottomFovRay","fovy2","fovy","matrix","first","second","a","b","normalize","cross","cosine","dot","sine","sign","atan2","pivot","fy","negate","left","extentToRectangle","projection","ext","Rectangle","fromDegrees","tileLayerToImageryLayer","olLayer","viewProj","external_ol_layer_Tile_default","external_ol_layer_Image_default","provider","getSource","external_ol_source_ImageWMS_default","getUrl","getImageLoadFunction","external_ol_source_Image_","sourceProps","olcs.proxy","olcs.extent","olcs.projection","olcs.imagesource","external_ol_source_TileWMS_default","params","getParams","setProperties","external_ol_source_TileImage_default","isCesiumProjection","external_ol_source_ImageStatic_default","SingleTileImageryProvider","getImageExtent","layerOptions","getExtent","ImageryLayer","updateCesiumLayerProperties","olLayerWithParents","csLayer","opacity","visible","concat","parents","forEach","layerOpacity","getOpacity","layerVisible","getVisible","alpha","show","coordinate","coo","ol4326CoordinateArrayToCsCartesians","toCartesian","cartesians","push","olGeometryCloneTo4326","proj4326","properties","getProperties","convertColorToCesium","olColor","Color","byteToFloat","fromCssColorString","CanvasPattern","CanvasGradient","ctx","getContext","fillStyle","fillRect","ImageMaterialProperty","image","convertUrlToCesium","subdomains","re","match","exec","replace","startCharCode","charCodeAt","stopCharCode","charCode","String","fromCharCode","resetToNorthZenith","Promise","resolve","reject","currentHeading","getRotation","view","normalizeView","rotateAroundBottomCenter","resolution","getResolution","setRotation","setResolution","constrainResolution","is3857","is4326","core","olcs_AutoRenderLoop","ol3d","scene_","getCesiumScene","canvas_","_boundNotifyRepaintRequired","notifyRepaintRequired","repaintEventNames_","enable","requestRenderMode","maximumRenderTimeChange","repaintKey","addEventListener","getOlMap","getLayerGroup","removeEventListener","un","requestRender","toDegrees","angleInRadians","toRadians","angleInDegrees","Camera_Camera","cam_","view_","viewListenKey_","toLonLat_","identityProjection","fromLonLat_","tilt_","distance_","lastCameraViewMatrix_","viewUpdateInProgress_","setView_","opt_output","opt_dimension","dim","external_ol_Observable_","toLonLat","fromLonLat","handleViewEvent_","readFromView","tilt","updateCamera_","updateView","setCenter","ll","carto","Cartographic","getAltitude","setView","destination","cartographicToCartesian","cartesianToCartographic","longitude","latitude","altitude","getHeight","orientation","pitch","PI_OVER_TWO","roll","moveBackward","checkCameraChange","calcDistanceForResolution","bestTarget","positionCartographic","bestTargetCartographic","calcResolutionForDistance","pos","targetNormal","targetToCamera","up","z","tiltAngle","acos","isNaN","opt_dontSync","old","current","viewMatrix","equalsEpsilon","metersPerUnit","getMetersPerUnit","cos","abs","tan","olcs_Camera","olcs_AbstractSynchronizer","olLayers","getLayers","mapLayerGroup","layerMap","olLayerListenKeys","olGroupListenKeys_","destroyAll","addLayers_","root","fifo","splice","olLayerId","toString","cesiumObjects","external_ol_layer_Group_default","listenForGroupChanges_","createSingleLayerCounterparts","newOlLayerWithParents","layerId","layerWithParents","onLayerChange","cesiumObjs","addCesiumObjects_","orderLayers","cesiumObject","addCesiumObject","uid","counterparts","counterpart","removeSingleCesiumObject","destroyCesiumObject","group","done","removeAndDestroySingleLayer_","unlistenSingleGroup_","uuid","listenKeyArray","contentKeys","listenAddRemove","collection","event","element","removeLayer_","el","indexOf","objKey","removeAllCesiumObjects","destroy","olcs_RasterSynchronizer","super","cesiumLayers_","imageryLayers","ourLayers_","ImageryLayerCollection","remove","removeAll","result","convertLayerToCesiumImageries","olLayerItem","synchronize","layers","zIndices","queue","getZIndex","sublayers","unshift","getArray","arr","compareFnc","index","sort","stableSort","layer1","layer2","raiseToTop","core_VectorLayerCounterpart","layerProjection","billboards","BillboardCollection","primitives","PrimitiveCollection","olListenKeys","rootCollection_","context","featureToCesiumMap","olcs_FeatureConverter","boundOnRemoveOrClearFeatureListener_","onRemoveOrClearFeature_","defaultBillboardEyeOffset_","evt","cancellers","feature","id","canceller","primitive","olFeature","olGeometry","color","opt_lineWidth","flat","renderState","depthTest","enabled","lineWidth","instances","instance","GeometryInstance","attributes","ColorGeometryInstanceAttribute","fromColor","createInstance","getHeightReference","HeightReference","CLAMP_TO_GROUND","ctor","constructor","GroundPrimitive","geometryInstances","Primitive","dataUri","getValue","toDataURL","appearance","MaterialAppearance","material","Material","fabric","uniforms","PerInstanceColorAppearance","setReferenceForPicking","outline","fillColor","getFill","getColor","strokeColor","getStroke","getWidth","fillGeometry","outlineGeometry","olStyle","extractColorFromOlStyle","outlineColor","p1","createColoredPrimitive","extractLineWidthFromOlStyle","p2","getText","text","label","olGeometry4326TextPartToCesium","bbOptions","eyeOffset","bb","point","slice","getRadius","radius","CircleGeometry","outlinePrimitive","circlePolygon","external_ol_geom_Polygon_","positions","getLinearRing","getCoordinates","GroundPolylineGeometry","PolylineMaterialAppearance","olStyleToCesium","classificationType","ClassificationType","TERRAIN","readyPromise","then","_primitive","createStackedGroundCorridors","CircleOutlineGeometry","extrudedHeight","wrapFillAndOutlineGeometries","addTextStyle","max","previousDistance","geometryOptions","vertexFormat","VertexFormat","POSITION_ONLY","linePositions","CorridorGeometry","distanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","heightReference","primitiveOptions","PolylineGeometry","getGeometry","external_ol_extent_","maxHeight","RectangleGeometry","RectangleOutlineGeometry","rings","getLinearRings","hierarchy","polygonHierarchy","olPos","holes","PolygonGeometry","perPositionHeight","polylineGeometry","PolygonOutlineGeometry","altitudeMode","NONE","RELATIVE_TO_GROUND","imageStyle","opt_newBillboardCallback","external_ol_style_Icon_default","load","getImage","reallyCreateBillboard","HTMLCanvasElement","HTMLImageElement","getScale","anchor","getAnchor","pixelOffset","csAddBillboard","src","naturalHeight","naturalWidth","complete","isImageLoaded","cancelled","fuid","isDestroyed","modelPrimitive","olcsModelFunction","olcsModel","assign","cesiumOptions","model","Model","fromGltf","debugModelMatrix","DebugModelMatrixPrimitive","modelMatrix","createBillboardFromImage","accumulate","geometries","functor","subgeos","getType","getPoints","olPointGeometryToCesium","getLineStrings","olLineStringGeometryToCesium","getPolygons","olPolygonGeometryToCesium","labels","LabelCollection","extentCenter","external_ol_geom_SimpleGeometry_default","getFirstCoordinate","offsetX","getOffsetX","offsetY","getOffsetY","offset","font","getFont","horizontalOrigin","labelStyle","LabelStyle","FILL","outlineWidth","OUTLINE","FILL_AND_OUTLINE","getTextAlign","HorizontalOrigin","LEFT","RIGHT","CENTER","getTextBaseline","verticalOrigin","VerticalOrigin","TOP","BOTTOM","fill","stroke","getLineDash","fromType","horizontal","repeat","evenColor","oddColor","fallbackStyleFunction","featureStyleFunction","getStyleFunction","opt_geom","geom3d","external_ol_geom_Geometry_default","geomFuncRes","getGeometryFunction","getGeometryFromFeature","newBillboardAddedCallback","featureBb","getGeometries","prims","olFeatureToCesium","bbs","olCircleGeometryToCesium","result2","olMultiGeometryToCesium","Error","olView","featurePrimitiveMap","external_ol_source_Cluster_default","features","getFeatures","layerStyle","styles","computePlainStyle","prim","getRootPrimitive","olcs_VectorSynchronizer","opt_converter","converter","csAllPrimitives_","destroyPrimitives","csPrimitive","external_ol_layer_Vector_default","external_ol_layer_VectorTile_default","olVectorLayerToCesium","csPrimitives","updateLayerVisibility","onAddFeature","convert","onRemoveFeature","Billboard","olcs_SynchronizedOverlay","external_ol_Overlay_default","parent","getOptions","scenePostRenderListenerRemover_","synchronizer_","synchronizer","parent_","positionWGS84_","observer_","MutationObserver","handleElementChanged","attributeObserver_","listenerKeys_","setPropertyFromEvent","setPropertyFromEvent_","handleMapChanged","disconnect","observe","childList","characterData","subtree","observer","childNodes","node","nodeType","set","parentNode","removeChild","getScene","postRender","updatePixelPosition","container","stopEvent","getOverlayContainerStopEvent","getOverlayContainer","insertFirst","insertBefore","appendChild","getPosition","sourceProjection","getMap","cloneNode","Node","TEXT_NODE","dispatchEvent","MouseEvent","stopPropagation","nodes","lastChild","removeChildren","getElement","clonedNode","observeTarget_","setVisible","globeHeight","tilesLoaded","cartesian","ellipsoidBoundingSphere","BoundingSphere","Occluder","isPointVisible","computeCullingVolume","computeVisibility","pixelCartesian","cartesianToCanvasCoordinates","mapSize","updateRenderedPosition","removeNode","olcs_OverlaySynchronizer","overlays_","getOverlays","overlayContainerStopEvent_","className","parentElement","overlayContainer_","overlayMap_","addOverlays","addOverlayFromEvent_","removeOverlayFromEvent_","overlay","addOverlay","cesiumOverlay","overlayId","removedOverlay","removeOverlay","csOverlay","keys","OLCesium_OLCesium","autoRenderLoop_","time_","time","JulianDate","to4326Transform_","resolutionScale_","canvasClientWidth_","canvasClientHeight_","resolutionScaleChanged_","fillArea","container_","containerAttribute","createAttribute","setAttributeNode","targetElement","getElementById","oc","getViewport","querySelector","isOverMap_","stopOpenLayersEventsPropagation","overlayEvents","ii","canvasAttribute","oncontextmenu","onselectstart","enabled_","pausedInteractions_","hiddenRootGroup_","sceneOptions","scene3DOnly","Scene","sscc","screenSpaceCameraController","tiltEventTypes","eventType","CameraEventType","LEFT_DRAG","modifier","KeyboardEventModifier","SHIFT","ALT","enableLook","constrainedAxis","camera_","globe_","Globe","baseColor","WHITE","skyAtmosphere","SkyAtmosphere","firstImageryProvider","addImageryProvider","dataSourceCollection_","DataSourceCollection","dataSourceDisplay_","DataSourceDisplay","dataSourceCollection","synchronizers","createSynchronizers","handleResize_","lastFrameTime_","renderId_","targetFrameRate_","Number","POSITIVE_INFINITY","blockCesiumRendering_","warmingUp_","trackedFeature_","trackedEntity_","entityView_","needTrackedEntityUpdate_","boundingSphereScratch_","EventHelper","updateTrackedEntity_","Camera","enableSuspendTerrainAdjustment","cancelAnimationFrame","onAnimationFrame_","frameTime","interval","render_","julianDate","initializeFrame","update","trackedEntity","getBoundingSphere","BoundingSphereState","DONE","render","state","PENDING","enableTilt","bs","FAILED","EntityView","mapProjection","resolutionScale","devicePixelRatio","aspectRatio","interactions","visibility","throwOnUnitializedMap_","getInteractions","clear","addInteraction","interaction","removeInteraction","filter","rootGroup","classList","timeout","csCamera","setTimeout","block","restartRenderLoop","isDef","trackedFeature","defaultDataSource","entities","IDENTITY","to4326Transform","toCesiumPosition","coo4326","CallbackProperty","TRANSPARENT","olcs_OLCesium","LazyLoader","promise","url_","script","onload","onerror","head","contrib_Manager","external_ol_Observable_default","cesiumUrl","cameraExtentInRadians","cesiumUrl_","boundingSphere_","blockLimiter_","promise_","cesiumInitialTilt_","fogDensity","fogSSEFactor","minimumZoomDistance","maximumZoomDistance","limitCameraToBoundingSphereRatio","cesiumLazyLoader","onCesiumLoaded","rect","DEFAULT_VIEW_RECTANGLE","fromRectangle3D","instantiateOLCesium","configureForUsability","configureForPerformance","terrainProvider","createWorldTerrain","fog","density","screenSpaceErrorFactor","sscController","depthTestAgainstTerrain","backgroundColor","limitCameraToBoundingSphere","enableAutoRenderLoop","fromCartesian","ratio","flying","unblockLimiter","flyToBoundingSphere","cancel","is3DCurrentlyEnabled","getEnabled","setEnabled","lon","lat","elevation","headingDeg","pitchDeg","getRectangleCameraCoordinates","mag","multiplyByScalar","flyTo","endTransform","olcs","__webpack_exports__","OLCesium","AbstractSynchronizer","RasterSynchronizer","VectorSynchronizer","OLImageryProvider","VectorLayerCounterpart","contrib","Manager"],"mappings":"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","file":"olcesium.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 23);\n","module.exports = ol.proj;","module.exports = ol.Observable;","module.exports = ol.layer.Group;","module.exports = ol.source.Vector;","module.exports = ol.layer.Image;","module.exports = ol.source.Cluster;","module.exports = ol.layer.Vector;","module.exports = ol.geom.Geometry;","module.exports = ol.style.Icon;","module.exports = ol.extent;","module.exports = ol.geom.Point;","module.exports = ol.easing;","module.exports = ol.layer.Tile;","module.exports = ol.source.ImageStatic;","module.exports = ol.source.ImageWMS;","module.exports = ol.source.TileImage;","module.exports = ol.source.TileWMS;","module.exports = ol.source.Image;","module.exports = ol.layer.Layer;","module.exports = ol.layer.VectorTile;","module.exports = ol.geom.Polygon;","module.exports = ol.geom.SimpleGeometry;","module.exports = ol.Overlay;","/**\r\n * @module olcs.util\r\n */\r\nconst exports = {};\r\n\r\n\r\n/**\r\n * Cast to object.\r\n * @param {Object} param\r\n * @return {Object}\r\n */\r\nexports.obj = function(param) {\r\n  return param;\r\n};\r\n\r\n\r\n/**\r\n * @type {boolean|undefined}\r\n * @private\r\n */\r\nexports.supportsImageRenderingPixelatedResult_ = undefined;\r\n\r\n\r\n/**\r\n * @type {string|undefined}\r\n * @private\r\n */\r\nexports.imageRenderingValueResult_ = undefined;\r\n\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nexports.supportsImageRenderingPixelated = function() {\r\n  if (exports.supportsImageRenderingPixelatedResult_ === undefined) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.setAttribute('style', 'image-rendering: -moz-crisp-edges; image-rendering: pixelated;');\r\n    // canvas.style.imageRendering will be undefined, null or an\r\n    // empty string on unsupported browsers.\r\n    const tmp = canvas.style['imageRendering']; // non standard\r\n    exports.supportsImageRenderingPixelatedResult_ = !!tmp;\r\n    if (exports.supportsImageRenderingPixelatedResult_) {\r\n      exports.imageRenderingValueResult_ = tmp;\r\n    }\r\n  }\r\n  return exports.supportsImageRenderingPixelatedResult_;\r\n};\r\n\r\n\r\n/**\r\n * @return {string}\r\n */\r\nexports.imageRenderingValue = function() {\r\n  exports.supportsImageRenderingPixelated();\r\n  return exports.imageRenderingValueResult_ || '';\r\n};\r\n\r\n/**\r\n * Return the projection of the source that Cesium should use.\r\n *\r\n * @param {ol.source.Source} source Source.\r\n * @returns {ol.proj.Projection} The projection of the source.\r\n */\r\nexports.getSourceProjection = function(source) {\r\n  return /** @type {ol.proj.Projection} */ (source.get('olcs.projection'))\r\n    || source.getProjection();\r\n};\r\n\r\n/**\r\n * @param {ol.Observable} observable\r\n * @param {string} type\r\n * @param {Function} listener\r\n * @return {!ol.events.EventsKey}\r\n */\r\nexport function olcsListen(observable, type, listener) {\r\n  // See https://github.com/openlayers/openlayers/pull/8481\r\n  // ol.events.listen is internal so we use `on` instead.\r\n  // And since `on` as a convoluted API (can return an EventsKey or an array of them)\r\n  // we use a cast here.\r\n  return /** @type {!ol.events.EventsKey} */ (observable.on(type, listener));\r\n}\r\n\r\n/**\r\n * Counter for getUid.\r\n * @type {number}\r\n */\r\nlet uidCounter_ = 0;\r\n\r\n/**\r\n * Gets a unique ID for an object. This mutates the object so that further calls\r\n * with the same object as a parameter returns the same value. Unique IDs are generated\r\n * as a strictly increasing sequence. Adapted from goog.getUid.\r\n *\r\n * @param {Object} obj The object to get the unique ID for.\r\n * @return {number} The unique ID for the object.\r\n */\r\nexport function getUid(obj) {\r\n  return obj.olcs_uid || (obj.olcs_uid = ++uidCounter_);\r\n}\r\n\r\n/**\r\n * Sort the passed array such that the relative order of equal elements is preverved.\r\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\r\n * @param {Array<*>} arr The array to sort (modifies original).\r\n * @param {!function(*, *): number} compareFnc Comparison function.\r\n */\r\nexport function stableSort(arr, compareFnc) {\r\n  const length = arr.length;\r\n  const tmp = Array(arr.length);\r\n  for (let i = 0; i < length; i++) {\r\n    tmp[i] = {index: i, value: arr[i]};\r\n  }\r\n  tmp.sort((a, b) => compareFnc(a.value, b.value) || a.index - b.index);\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = tmp[i].value;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove.\r\n * @returns {Node} The node that was removed or null.\r\n */\r\nexport function removeNode(node) {\r\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove the children from.\r\n */\r\nexport function removeChildren(node) {\r\n  while (node.lastChild) {\r\n    node.removeChild(node.lastChild);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Cesium.Scene} scene The scene.\r\n */\r\nexport function isGroundPolylinePrimitiveSupported(scene) {\r\n  const obj = Cesium.GroundPolylinePrimitive;\r\n  return obj && obj.isSupported(scene);\r\n}\r\n\r\nexport default exports;\r\n","/**\r\n * @module olcs.core.OLImageryProvider\r\n */\r\nimport {get as getProjection} from 'ol/proj.js';\r\nimport olcsUtil from '../util.js';\r\n\r\nclass OLImageryProvider /* should not extend Cesium.ImageryProvider */ {\r\n  /**\r\n   * Special class derived from Cesium.ImageryProvider\r\n   * that is connected to the given ol.source.TileImage.\r\n   * @param {!ol.Map} olMap\r\n   * @param {!ol.source.TileImage} source\r\n   * @param {ol.proj.Projection=} opt_fallbackProj Projection to assume if the\r\n   *                                               projection of the source is not defined.\r\n   * @constructor\r\n   * @extends {Cesium.ImageryProvider}\r\n   */\r\n  constructor(olMap, source, opt_fallbackProj) {\r\n    // Do not extend or call super constructor from\r\n    // Cesium.ImageryProvider since this particular function is a\r\n    // 'non instanciable interface' which throws on instanciation.\r\n\r\n    /**\r\n     * @type {!ol.source.TileImage}\r\n     * @private\r\n     */\r\n    this.source_ = source;\r\n\r\n    /**\r\n     * @type {?ol.proj.Projection}\r\n     * @private\r\n     */\r\n    this.projection_ = null;\r\n\r\n    /**\r\n     * @type {?ol.proj.Projection}\r\n     * @private\r\n     */\r\n    this.fallbackProj_ = opt_fallbackProj || null;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.ready_ = false;\r\n\r\n    /**\r\n     * @type {?Cesium.TilingScheme}\r\n     * @private\r\n     */\r\n    this.tilingScheme_ = null;\r\n\r\n    /**\r\n     * @type {?Cesium.Rectangle}\r\n     * @private\r\n     */\r\n    this.rectangle_ = null;\r\n\r\n    /**\r\n     * @type {!ol.Map}\r\n     * @private\r\n     */\r\n    this.map_ = olMap;\r\n\r\n    const proxy = this.source_.get('olcs.proxy');\r\n    if (proxy) {\r\n      if (typeof proxy === 'function') {\r\n        this.proxy_ = {\r\n          'getURL': proxy\r\n        };\r\n      } else if (typeof proxy === 'string') {\r\n        this.proxy_ = new Cesium.DefaultProxy(proxy);\r\n      }\r\n    }\r\n\r\n    this.errorEvent_ = new Cesium.Event();\r\n\r\n    this.emptyCanvas_ = document.createElement('canvas');\r\n    this.emptyCanvas_.width = 1;\r\n    this.emptyCanvas_.height = 1;\r\n\r\n    this.source_.on('change', (e) => {\r\n      this.handleSourceChanged_();\r\n    });\r\n    this.handleSourceChanged_();\r\n  }\r\n\r\n  /**\r\n   * Checks if the underlying source is ready and cached required data.\r\n   * @private\r\n   */\r\n  handleSourceChanged_(frameState) {\r\n    if (!this.ready_ && this.source_.getState() == 'ready') {\r\n      this.projection_ = olcsUtil.getSourceProjection(this.source_) || this.fallbackProj_;\r\n      if (this.projection_ == getProjection('EPSG:4326')) {\r\n        this.tilingScheme_ = new Cesium.GeographicTilingScheme();\r\n      } else if (this.projection_ == getProjection('EPSG:3857')) {\r\n        this.tilingScheme_ = new Cesium.WebMercatorTilingScheme();\r\n      } else {\r\n        return;\r\n      }\r\n      this.rectangle_ = this.tilingScheme_.rectangle;\r\n\r\n      this.ready_ = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the proper attributions for a given position and zoom\r\n   * level.\r\n   * @export\r\n   * @override\r\n   */\r\n  getTileCredits(x, y, level) {\r\n    const extent = this.map_.getView().calculateExtent(this.map_.getSize());\r\n    const center = this.map_.getView().getCenter();\r\n    const zoom = this.tilingScheme_ instanceof Cesium.GeographicTilingScheme ? level + 1 : level;\r\n\r\n    const frameState = {\r\n      viewState: {zoom, center},\r\n      extent,\r\n    };\r\n\r\n    const attributionsFunction = this.source_.getAttributions();\r\n    if (!attributionsFunction) {\r\n      return [];\r\n    }\r\n    let attributions = attributionsFunction(frameState);\r\n    if (!Array.isArray(attributions)) {\r\n      attributions = [attributions];\r\n    }\r\n\r\n    return attributions.map(html => new Cesium.Credit(html, true));\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @override\r\n   */\r\n  requestImage(x, y, level) {\r\n    const tileUrlFunction = this.source_.getTileUrlFunction();\r\n    if (tileUrlFunction && this.projection_) {\r\n\r\n      // Perform mapping of Cesium tile coordinates to OpenLayers tile coordinates:\r\n      // 1) Cesium zoom level 0 is OpenLayers zoom level 1 for EPSG:4326\r\n      const z_ = this.tilingScheme_ instanceof Cesium.GeographicTilingScheme ? level + 1 : level;\r\n      // 2) OpenLayers tile coordinates increase from bottom to top\r\n      const y_ = -y - 1;\r\n\r\n      let url = tileUrlFunction.call(this.source_,\r\n          [z_, x, y_], 1, this.projection_);\r\n      if (this.proxy_) {\r\n        url = this.proxy_.getURL(url);\r\n      }\r\n      return url ? Cesium.ImageryProvider.loadImage(this, url) : this.emptyCanvas_;\r\n    } else {\r\n      // return empty canvas to stop Cesium from retrying later\r\n      return this.emptyCanvas_;\r\n    }\r\n  }\r\n}\r\n\r\n// definitions of getters that are required to be present\r\n// in the Cesium.ImageryProvider instance:\r\nObject.defineProperties(OLImageryProvider.prototype, {\r\n  'ready': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {return this.ready_;}\r\n  },\r\n\r\n  'rectangle': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {return this.rectangle_;}\r\n  },\r\n\r\n  'tileWidth': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {\r\n          const tg = this.source_.getTileGrid();\r\n          return tg ? (Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[0] : tg.getTileSize(0)) : 256;\r\n        }\r\n  },\r\n\r\n  'tileHeight': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {\r\n          const tg = this.source_.getTileGrid();\r\n          return tg ? (Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[1] : tg.getTileSize(0)) : 256;\r\n        }\r\n  },\r\n\r\n  'maximumLevel': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {\r\n          const tg = this.source_.getTileGrid();\r\n          return tg ? tg.getMaxZoom() : 18;\r\n        }\r\n  },\r\n\r\n  'minimumLevel': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {\r\n          // WARNING: Do not use the minimum level (at least until the extent is\r\n          // properly set). Cesium assumes the minimumLevel to contain only\r\n          // a few tiles and tries to load them all at once -- this can\r\n          // freeze and/or crash the browser !\r\n          return 0;\r\n          //var tg = this.source_.getTileGrid();\r\n          //return tg ? tg.getMinZoom() : 0;\r\n        }\r\n  },\r\n\r\n  'tilingScheme': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {return this.tilingScheme_;}\r\n  },\r\n\r\n  'tileDiscardPolicy': {\r\n    'get': function() {return undefined;}\r\n  },\r\n\r\n  'errorEvent': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {return this.errorEvent_;}\r\n  },\r\n\r\n  'proxy': {\r\n    'get': /** @this {olcs.core.OLImageryProvider} */\r\n        function() {return this.proxy_;}\r\n  },\r\n\r\n  'hasAlphaChannel': {\r\n    'get': function() {return true;}\r\n  },\r\n\r\n  'pickFeatures': {\r\n    'get': function() {return undefined;}\r\n  }\r\n});\r\n\r\n\r\nexport default OLImageryProvider;\r\n","/**\r\n * @module olcs.core\r\n */\r\nimport {linear as linearEasing} from 'ol/easing.js';\r\nimport olLayerTile from 'ol/layer/Tile.js';\r\nimport olLayerImage from 'ol/layer/Image.js';\r\nimport {get as getProjection, transformExtent} from 'ol/proj.js';\r\nimport olSourceImageStatic from 'ol/source/ImageStatic';\r\nimport olSourceImageWMS from 'ol/source/ImageWMS.js';\r\nimport olSourceTileImage from 'ol/source/TileImage.js';\r\nimport olSourceTileWMS from 'ol/source/TileWMS.js';\r\nimport {defaultImageLoadFunction} from 'ol/source/Image.js';\r\nimport olcsCoreOLImageryProvider from './core/OLImageryProvider.js';\r\nimport olcsUtil from './util.js';\r\n\r\n\r\nconst exports = {};\r\n\r\n\r\n/**\r\n * @typedef {Object} CesiumUrlDefinition\r\n * @property {string} url\r\n * @property {string} subdomains\r\n */\r\n\r\n\r\n/**\r\n * Options for rotate around axis core function.\r\n * @typedef {Object} RotateAroundAxisOption\r\n * @property {number} [duration]\r\n * @property {function(number): number} [easing]\r\n * @property {function(): void} [callback]\r\n */\r\n\r\n\r\n\r\n/**\r\n * @typedef {Object} LayerWithParents\r\n * @property {import('ol/layer/Base.js').default} layer\r\n * @property {Array<import('ol/layer/Group.js').default>} parents\r\n */\r\n\r\n\r\n/**\r\n * Compute the pixel width and height of a point in meters using the\r\n * camera frustum.\r\n * @param {!Cesium.Scene} scene\r\n * @param {!Cesium.Cartesian3} target\r\n * @return {!Cesium.Cartesian2} the pixel size\r\n * @api\r\n */\r\nexports.computePixelSizeAtCoordinate = function(scene, target) {\r\n  const camera = scene.camera;\r\n  const canvas = scene.canvas;\r\n  const frustum = camera.frustum;\r\n  const distance = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(\r\n      camera.position, target, new Cesium.Cartesian3()));\r\n  const pixelSize = new Cesium.Cartesian2();\r\n  return frustum.getPixelDimensions(canvas.clientWidth, canvas.clientHeight,\r\n      distance, pixelSize);\r\n};\r\n\r\n\r\n/**\r\n * Compute bounding box around a target point.\r\n * @param {!Cesium.Scene} scene\r\n * @param {!Cesium.Cartesian3} target\r\n * @param {number} amount Half the side of the box, in pixels.\r\n * @return {Array<Cesium.Cartographic>} bottom left and top right\r\n * coordinates of the box\r\n */\r\nexports.computeBoundingBoxAtTarget = function(scene, target, amount) {\r\n  const pixelSize = exports.computePixelSizeAtCoordinate(scene, target);\r\n  const transform = Cesium.Transforms.eastNorthUpToFixedFrame(target);\r\n\r\n  const bottomLeft = Cesium.Matrix4.multiplyByPoint(\r\n      transform,\r\n      new Cesium.Cartesian3(-pixelSize.x * amount, -pixelSize.y * amount, 0),\r\n      new Cesium.Cartesian3());\r\n\r\n  const topRight = Cesium.Matrix4.multiplyByPoint(\r\n      transform,\r\n      new Cesium.Cartesian3(pixelSize.x * amount, pixelSize.y * amount, 0),\r\n      new Cesium.Cartesian3());\r\n\r\n  return Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(\r\n      [bottomLeft, topRight]);\r\n};\r\n\r\n\r\n/**\r\n *\r\n * @param {!ol.geom.Geometry} geometry\r\n * @param {number} height\r\n * @api\r\n */\r\nexports.applyHeightOffsetToGeometry = function(geometry, height) {\r\n  geometry.applyTransform((input, output, stride) => {\r\n    console.assert(input === output);\r\n    if (stride !== undefined && stride >= 3) {\r\n      for (let i = 0; i < output.length; i += stride) {\r\n        output[i + 2] = output[i + 2] + height;\r\n      }\r\n    }\r\n    return output;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * @param {ol.Coordinate} coordinates\r\n * @param {number=} rotation\r\n * @param {!Cesium.Cartesian3=} translation\r\n * @param {!Cesium.Cartesian3=} scale\r\n * @return {!Cesium.Matrix4}\r\n * @api\r\n */\r\nexports.createMatrixAtCoordinates = function(coordinates, rotation = 0, translation = Cesium.Cartesian3.ZERO, scale = new Cesium.Cartesian3(1, 1, 1)) {\r\n  const position = exports.ol4326CoordinateToCesiumCartesian(coordinates);\r\n  const rawMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);\r\n  const quaternion = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -rotation);\r\n  const rotationMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(translation, quaternion, scale);\r\n  return Cesium.Matrix4.multiply(rawMatrix, rotationMatrix, new Cesium.Matrix4());\r\n};\r\n\r\n\r\n/**\r\n * @param {!Cesium.Camera} camera\r\n * @param {number} angle\r\n * @param {!Cesium.Cartesian3} axis\r\n * @param {!Cesium.Matrix4} transform\r\n * @param {RotateAroundAxisOption=} opt_options\r\n * @api\r\n */\r\nexports.rotateAroundAxis = function(camera, angle, axis, transform,\r\n    opt_options) {\r\n  const clamp = Cesium.Math.clamp;\r\n  const defaultValue = Cesium.defaultValue;\r\n\r\n  const options = opt_options || {};\r\n  const duration = defaultValue(options.duration, 500); // ms\r\n  const easing = defaultValue(options.easing, linearEasing);\r\n  const callback = options.callback;\r\n\r\n  let lastProgress = 0;\r\n  const oldTransform = new Cesium.Matrix4();\r\n\r\n  const start = Date.now();\r\n  const step = function() {\r\n    const timestamp = Date.now();\r\n    const timeDifference = timestamp - start;\r\n    const progress = easing(clamp(timeDifference / duration, 0, 1));\r\n    console.assert(progress >= lastProgress);\r\n\r\n    camera.transform.clone(oldTransform);\r\n    const stepAngle = (progress - lastProgress) * angle;\r\n    lastProgress = progress;\r\n    camera.lookAtTransform(transform);\r\n    camera.rotate(axis, stepAngle);\r\n    camera.lookAtTransform(oldTransform);\r\n\r\n    if (progress < 1) {\r\n      window.requestAnimationFrame(step);\r\n    } else {\r\n      if (callback) {\r\n        callback();\r\n      }\r\n    }\r\n  };\r\n  window.requestAnimationFrame(step);\r\n};\r\n\r\n\r\n/**\r\n * @param {!Cesium.Scene} scene\r\n * @param {number} heading\r\n * @param {!Cesium.Cartesian3} bottomCenter\r\n * @param {RotateAroundAxisOption=} opt_options\r\n * @api\r\n */\r\nexports.setHeadingUsingBottomCenter = function(scene, heading,\r\n    bottomCenter, opt_options) {\r\n  const camera = scene.camera;\r\n  // Compute the camera position to zenith quaternion\r\n  const angleToZenith = exports.computeAngleToZenith(scene, bottomCenter);\r\n  const axis = camera.right;\r\n  const quaternion = Cesium.Quaternion.fromAxisAngle(axis, angleToZenith);\r\n  const rotation = Cesium.Matrix3.fromQuaternion(quaternion);\r\n\r\n  // Get the zenith point from the rotation of the position vector\r\n  const vector = new Cesium.Cartesian3();\r\n  Cesium.Cartesian3.subtract(camera.position, bottomCenter, vector);\r\n  const zenith = new Cesium.Cartesian3();\r\n  Cesium.Matrix3.multiplyByVector(rotation, vector, zenith);\r\n  Cesium.Cartesian3.add(zenith, bottomCenter, zenith);\r\n\r\n  // Actually rotate around the zenith normal\r\n  const transform = Cesium.Matrix4.fromTranslation(zenith);\r\n  const rotateAroundAxis = exports.rotateAroundAxis;\r\n  rotateAroundAxis(camera, heading, zenith, transform, opt_options);\r\n};\r\n\r\n\r\n/**\r\n * Get the 3D position of the given pixel of the canvas.\r\n * @param {!Cesium.Scene} scene\r\n * @param {!Cesium.Cartesian2} pixel\r\n * @return {!Cesium.Cartesian3|undefined}\r\n * @api\r\n */\r\nexports.pickOnTerrainOrEllipsoid = function(scene, pixel) {\r\n  const ray = scene.camera.getPickRay(pixel);\r\n  const target = scene.globe.pick(ray, scene);\r\n  return target || scene.camera.pickEllipsoid(pixel);\r\n};\r\n\r\n\r\n/**\r\n * Get the 3D position of the point at the bottom-center of the screen.\r\n * @param {!Cesium.Scene} scene\r\n * @return {!Cesium.Cartesian3|undefined}\r\n * @api\r\n */\r\nexports.pickBottomPoint = function(scene) {\r\n  const canvas = scene.canvas;\r\n  const bottom = new Cesium.Cartesian2(\r\n      canvas.clientWidth / 2, canvas.clientHeight);\r\n  return exports.pickOnTerrainOrEllipsoid(scene, bottom);\r\n};\r\n\r\n\r\n/**\r\n * Get the 3D position of the point at the center of the screen.\r\n * @param {!Cesium.Scene} scene\r\n * @return {!Cesium.Cartesian3|undefined}\r\n * @api\r\n */\r\nexports.pickCenterPoint = function(scene) {\r\n  const canvas = scene.canvas;\r\n  const center = new Cesium.Cartesian2(\r\n      canvas.clientWidth / 2,\r\n      canvas.clientHeight / 2);\r\n  return exports.pickOnTerrainOrEllipsoid(scene, center);\r\n};\r\n\r\n\r\n/**\r\n * Compute the signed tilt angle on globe, between the opposite of the\r\n * camera direction and the target normal. Return undefined if there is no\r\n * intersection of the camera direction with the globe.\r\n * @param {!Cesium.Scene} scene\r\n * @return {number|undefined}\r\n * @api\r\n */\r\nexports.computeSignedTiltAngleOnGlobe = function(scene) {\r\n  const camera = scene.camera;\r\n  const ray = new Cesium.Ray(camera.position, camera.direction);\r\n  let target = scene.globe.pick(ray, scene);\r\n\r\n  if (!target) {\r\n    // no tiles in the area were loaded?\r\n    const ellipsoid = Cesium.Ellipsoid.WGS84;\r\n    const obj = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\r\n    if (obj) {\r\n      target = Cesium.Ray.getPoint(ray, obj.start);\r\n    }\r\n  }\r\n\r\n  if (!target) {\r\n    return undefined;\r\n  }\r\n\r\n  const normal = new Cesium.Cartesian3();\r\n  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(target, normal);\r\n\r\n  const angleBetween = exports.signedAngleBetween;\r\n  const angle = angleBetween(camera.direction, normal, camera.right) - Math.PI;\r\n  return Cesium.Math.convertLongitudeRange(angle);\r\n};\r\n\r\n\r\n/**\r\n * Compute the ray from the camera to the bottom-center of the screen.\r\n * @param {!Cesium.Scene} scene\r\n * @return {!Cesium.Ray}\r\n */\r\nexports.bottomFovRay = function(scene) {\r\n  const camera = scene.camera;\r\n  const fovy2 = camera.frustum.fovy / 2;\r\n  const direction = camera.direction;\r\n  const rotation = Cesium.Quaternion.fromAxisAngle(camera.right, fovy2);\r\n  const matrix = Cesium.Matrix3.fromQuaternion(rotation);\r\n  const vector = new Cesium.Cartesian3();\r\n  Cesium.Matrix3.multiplyByVector(matrix, direction, vector);\r\n  return new Cesium.Ray(camera.position, vector);\r\n};\r\n\r\n\r\n/**\r\n * Compute the angle between two Cartesian3.\r\n * @param {!Cesium.Cartesian3} first\r\n * @param {!Cesium.Cartesian3} second\r\n * @param {!Cesium.Cartesian3} normal Normal to test orientation against.\r\n * @return {number}\r\n */\r\nexports.signedAngleBetween = function(first, second, normal) {\r\n  // We are using the dot for the angle.\r\n  // Then the cross and the dot for the sign.\r\n  const a = new Cesium.Cartesian3();\r\n  const b = new Cesium.Cartesian3();\r\n  const c = new Cesium.Cartesian3();\r\n  Cesium.Cartesian3.normalize(first, a);\r\n  Cesium.Cartesian3.normalize(second, b);\r\n  Cesium.Cartesian3.cross(a, b, c);\r\n\r\n  const cosine = Cesium.Cartesian3.dot(a, b);\r\n  const sine = Cesium.Cartesian3.magnitude(c);\r\n\r\n  // Sign of the vector product and the orientation normal\r\n  const sign = Cesium.Cartesian3.dot(normal, c);\r\n  const angle = Math.atan2(sine, cosine);\r\n  return sign >= 0 ? angle : -angle;\r\n};\r\n\r\n\r\n/**\r\n * Compute the rotation angle around a given point, needed to reach the\r\n * zenith position.\r\n * At a zenith position, the camera direction is going througth the earth\r\n * center and the frustrum bottom ray is going through the chosen pivot\r\n * point.\r\n * The bottom-center of the screen is a good candidate for the pivot point.\r\n * @param {!Cesium.Scene} scene\r\n * @param {!Cesium.Cartesian3} pivot Point around which the camera rotates.\r\n * @return {number}\r\n * @api\r\n */\r\nexports.computeAngleToZenith = function(scene, pivot) {\r\n  // This angle is the sum of the angles 'fy' and 'a', which are defined\r\n  // using the pivot point and its surface normal.\r\n  //        Zenith |    camera\r\n  //           \\   |   /\r\n  //            \\fy|  /\r\n  //             \\ |a/\r\n  //              \\|/pivot\r\n  const camera = scene.camera;\r\n  const fy = camera.frustum.fovy / 2;\r\n  const ray = exports.bottomFovRay(scene);\r\n  const direction = Cesium.Cartesian3.clone(ray.direction);\r\n  Cesium.Cartesian3.negate(direction, direction);\r\n\r\n  const normal = new Cesium.Cartesian3();\r\n  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(pivot, normal);\r\n\r\n  const left = new Cesium.Cartesian3();\r\n  Cesium.Cartesian3.negate(camera.right, left);\r\n\r\n  const a = exports.signedAngleBetween(normal, direction, left);\r\n  return a + fy;\r\n};\r\n\r\n\r\n/**\r\n * Convert an OpenLayers extent to a Cesium rectangle.\r\n * @param {ol.Extent} extent Extent.\r\n * @param {ol.ProjectionLike} projection Extent projection.\r\n * @return {Cesium.Rectangle} The corresponding Cesium rectangle.\r\n * @api\r\n */\r\nexports.extentToRectangle = function(extent, projection) {\r\n  if (extent && projection) {\r\n    const ext = transformExtent(extent, projection, 'EPSG:4326');\r\n    return Cesium.Rectangle.fromDegrees(ext[0], ext[1], ext[2], ext[3]);\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Creates Cesium.ImageryLayer best corresponding to the given ol.layer.Layer.\r\n * Only supports raster layers and static images\r\n * @param {!ol.Map} olMap\r\n * @param {!ol.layer.Base} olLayer\r\n * @param {!ol.proj.Projection} viewProj Projection of the view.\r\n * @return {?Cesium.ImageryLayer} null if not possible (or supported)\r\n * @api\r\n */\r\nexports.tileLayerToImageryLayer = function(olMap, olLayer, viewProj) {\r\n\r\n  if (!(olLayer instanceof olLayerTile) && !(olLayer instanceof olLayerImage)) {\r\n    return null;\r\n  }\r\n\r\n  let provider = null;\r\n  let source = olLayer.getSource();\r\n\r\n  // Convert ImageWMS to TileWMS\r\n  if (source instanceof olSourceImageWMS && source.getUrl() &&\r\n    source.getImageLoadFunction() === defaultImageLoadFunction) {\r\n    const sourceProps = {\r\n      'olcs.proxy': source.get('olcs.proxy'),\r\n      'olcs.extent': source.get('olcs.extent'),\r\n      'olcs.projection': source.get('olcs.projection'),\r\n      'olcs.imagesource': source\r\n    };\r\n    source = new olSourceTileWMS({\r\n      url: source.getUrl(),\r\n      attributions: source.getAttributions(),\r\n      projection: source.getProjection(),\r\n      params: source.getParams()\r\n    });\r\n    source.setProperties(sourceProps);\r\n  }\r\n\r\n  if (source instanceof olSourceTileImage) {\r\n    let projection = olcsUtil.getSourceProjection(source);\r\n\r\n    if (!projection) {\r\n      // if not explicit, assume the same projection as view\r\n      projection = viewProj;\r\n    }\r\n\r\n    if (exports.isCesiumProjection(projection)) {\r\n      provider = new olcsCoreOLImageryProvider(olMap, source, viewProj);\r\n    }\r\n    // Projection not supported by Cesium\r\n    else {\r\n      return null;\r\n    }\r\n\r\n  } else if (source instanceof olSourceImageStatic) {\r\n    let projection = olcsUtil.getSourceProjection(source);\r\n\r\n    if (!projection) {\r\n      projection = viewProj;\r\n    }\r\n\r\n    if (exports.isCesiumProjection(projection)) {\r\n      provider = new Cesium.SingleTileImageryProvider({\r\n        url: source.getUrl(),\r\n        rectangle: new Cesium.Rectangle.fromDegrees(\r\n            source.getImageExtent()[0],\r\n            source.getImageExtent()[1],\r\n            source.getImageExtent()[2],\r\n            source.getImageExtent()[3]\r\n        )\r\n      });\r\n    }\r\n    // Projection not supported by Cesium\r\n    else {\r\n      return null;\r\n    }\r\n  } else {\r\n    // sources other than TileImage|ImageStatic are currently not supported\r\n    return null;\r\n  }\r\n\r\n  // the provider is always non-null if we got this far\r\n\r\n  const layerOptions = {};\r\n\r\n  const forcedExtent = /** @type {ol.Extent} */ (olLayer.get('olcs.extent'));\r\n  const ext = forcedExtent || olLayer.getExtent();\r\n  if (ext) {\r\n    layerOptions.rectangle = exports.extentToRectangle(ext, viewProj);\r\n  }\r\n\r\n  const cesiumLayer = new Cesium.ImageryLayer(provider, layerOptions);\r\n  return cesiumLayer;\r\n};\r\n\r\n\r\n/**\r\n * Synchronizes the layer rendering properties (opacity, visible)\r\n * to the given Cesium ImageryLayer.\r\n * @param {olcsx.LayerWithParents} olLayerWithParents\r\n * @param {!Cesium.ImageryLayer} csLayer\r\n * @api\r\n */\r\nexports.updateCesiumLayerProperties = function(olLayerWithParents, csLayer) {\r\n  let opacity = 1;\r\n  let visible = true;\r\n  [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayer) => {\r\n    const layerOpacity = olLayer.getOpacity();\r\n    if (layerOpacity !== undefined) {\r\n      opacity *= layerOpacity;\r\n    }\r\n    const layerVisible = olLayer.getVisible();\r\n    if (layerVisible !== undefined) {\r\n      visible &= layerVisible;\r\n    }\r\n  });\r\n  csLayer.alpha = opacity;\r\n  csLayer.show = visible;\r\n};\r\n\r\n\r\n/**\r\n * Convert a 2D or 3D OpenLayers coordinate to Cesium.\r\n * @param {ol.Coordinate} coordinate Ol3 coordinate.\r\n * @return {!Cesium.Cartesian3} Cesium cartesian coordinate\r\n * @api\r\n */\r\nexports.ol4326CoordinateToCesiumCartesian = function(coordinate) {\r\n  const coo = coordinate;\r\n  return coo.length > 2 ?\r\n    Cesium.Cartesian3.fromDegrees(coo[0], coo[1], coo[2]) :\r\n    Cesium.Cartesian3.fromDegrees(coo[0], coo[1]);\r\n};\r\n\r\n\r\n/**\r\n * Convert an array of 2D or 3D OpenLayers coordinates to Cesium.\r\n * @param {Array.<!ol.Coordinate>} coordinates Ol3 coordinates.\r\n * @return {!Array.<Cesium.Cartesian3>} Cesium cartesian coordinates\r\n * @api\r\n */\r\nexports.ol4326CoordinateArrayToCsCartesians = function(coordinates) {\r\n  console.assert(coordinates !== null);\r\n  const toCartesian = exports.ol4326CoordinateToCesiumCartesian;\r\n  const cartesians = [];\r\n  for (let i = 0; i < coordinates.length; ++i) {\r\n    cartesians.push(toCartesian(coordinates[i]));\r\n  }\r\n  return cartesians;\r\n};\r\n\r\n\r\n/**\r\n * Reproject an OpenLayers geometry to EPSG:4326 if needed.\r\n * The geometry will be cloned only when original projection is not EPSG:4326\r\n * and the properties will be shallow copied.\r\n * @param {!T} geometry\r\n * @param {!ol.ProjectionLike} projection\r\n * @return {!T}\r\n * @template T\r\n * @api\r\n */\r\nexports.olGeometryCloneTo4326 = function(geometry, projection) {\r\n  console.assert(projection);\r\n\r\n  const proj4326 = getProjection('EPSG:4326');\r\n  const proj = getProjection(projection);\r\n  if (proj !== proj4326) {\r\n    const properties = geometry.getProperties();\r\n    geometry = geometry.clone();\r\n    geometry.transform(proj, proj4326);\r\n    geometry.setProperties(properties);\r\n  }\r\n  return geometry;\r\n};\r\n\r\n\r\n/**\r\n * Convert an OpenLayers color to Cesium.\r\n * @param {ol.Color|CanvasGradient|CanvasPattern|string} olColor\r\n * @return {!Cesium.Color}\r\n * @api\r\n */\r\nexports.convertColorToCesium = function(olColor) {\r\n  olColor = olColor || 'black';\r\n  if (Array.isArray(olColor)) {\r\n    return new Cesium.Color(\r\n        Cesium.Color.byteToFloat(olColor[0]),\r\n        Cesium.Color.byteToFloat(olColor[1]),\r\n        Cesium.Color.byteToFloat(olColor[2]),\r\n        olColor[3]\r\n    );\r\n  } else if (typeof olColor == 'string') {\r\n    return Cesium.Color.fromCssColorString(olColor);\r\n  } else if (olColor instanceof CanvasPattern || olColor instanceof CanvasGradient) {\r\n    // Render the CanvasPattern/CanvasGradient into a canvas that will be sent to Cesium as material\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    canvas.width = canvas.height = 256;\r\n    ctx.fillStyle = olColor;\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    return new Cesium.ImageMaterialProperty({\r\n      image: canvas\r\n    });\r\n  }\r\n  console.assert(false, 'impossible');\r\n};\r\n\r\n\r\n/**\r\n * Convert an OpenLayers url to Cesium.\r\n * @param {string} url\r\n * @return {!CesiumUrlDefinition}\r\n * @api\r\n */\r\nexports.convertUrlToCesium = function(url) {\r\n  let subdomains = '';\r\n  const re = /\\{(\\d|[a-z])-(\\d|[a-z])\\}/;\r\n  const match = re.exec(url);\r\n  if (match) {\r\n    url = url.replace(re, '{s}');\r\n    const startCharCode = match[1].charCodeAt(0);\r\n    const stopCharCode = match[2].charCodeAt(0);\r\n    let charCode;\r\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\r\n      subdomains += String.fromCharCode(charCode);\r\n    }\r\n  }\r\n  return {\r\n    url,\r\n    subdomains\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Animate the return to a top-down view from the zenith.\r\n * The camera is rotated to orient to the North.\r\n * @param {!ol.Map} map\r\n * @param {!Cesium.Scene} scene\r\n * @return {Promise<undefined>}\r\n * @api\r\n */\r\nexports.resetToNorthZenith = function(map, scene) {\r\n  return new Promise((resolve, reject) => {\r\n    const camera = scene.camera;\r\n    const pivot = exports.pickBottomPoint(scene);\r\n    if (!pivot) {\r\n      reject('Could not get bottom pivot');\r\n      return;\r\n    }\r\n\r\n    const currentHeading = map.getView().getRotation();\r\n    if (currentHeading === undefined) {\r\n      reject('The view is not initialized');\r\n      return;\r\n    }\r\n    const angle = exports.computeAngleToZenith(scene, pivot);\r\n\r\n    // Point to North\r\n    exports.setHeadingUsingBottomCenter(scene, currentHeading, pivot);\r\n\r\n    // Go to zenith\r\n    const transform = Cesium.Matrix4.fromTranslation(pivot);\r\n    const axis = camera.right;\r\n    const options = {\r\n      callback: () => {\r\n        const view = map.getView();\r\n        exports.normalizeView(view);\r\n        resolve();\r\n      }\r\n    };\r\n    exports.rotateAroundAxis(camera, -angle, axis, transform, options);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * @param {!Cesium.Scene} scene\r\n * @param {number} angle in radian\r\n * @return {Promise<undefined>}\r\n * @api\r\n */\r\nexports.rotateAroundBottomCenter = function(scene, angle) {\r\n  return new Promise((resolve, reject) => {\r\n    const camera = scene.camera;\r\n    const pivot = exports.pickBottomPoint(scene);\r\n    if (!pivot) {\r\n      reject('could not get bottom pivot');\r\n      return;\r\n    }\r\n\r\n    const options = {callback: resolve};\r\n    const transform = Cesium.Matrix4.fromTranslation(pivot);\r\n    const axis = camera.right;\r\n    const rotateAroundAxis = exports.rotateAroundAxis;\r\n    rotateAroundAxis(camera, -angle, axis, transform, options);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Set the OpenLayers view to a specific rotation and\r\n * the nearest resolution.\r\n * @param {ol.View} view\r\n * @param {number=} angle\r\n * @api\r\n */\r\nexports.normalizeView = function(view, angle = 0) {\r\n  const resolution = view.getResolution();\r\n  view.setRotation(angle);\r\n  view.setResolution(view.constrainResolution(resolution));\r\n};\r\n\r\n/**\r\n * Check if the given projection is managed by Cesium (WGS84 or Mercator Spheric)\r\n *\r\n * @param {ol.proj.Projection} projection Projection to check.\r\n * @returns {boolean} Whether it's managed by Cesium.\r\n */\r\nexports.isCesiumProjection = function(projection) {\r\n  const is3857 = projection === getProjection('EPSG:3857');\r\n  const is4326 = projection === getProjection('EPSG:4326');\r\n  return is3857 || is4326;\r\n};\r\n\r\n\r\nexport default exports;\r\n","/**\r\n * @module olcs.AutoRenderLoop\r\n */\r\n\r\nclass AutoRenderLoop {\r\n  /**\r\n   * @constructor\r\n   * @param {olcs.OLCesium} ol3d\r\n   */\r\n  constructor(ol3d) {\r\n    this.ol3d = ol3d;\r\n    this.scene_ = ol3d.getCesiumScene();\r\n    this.canvas_ = this.scene_.canvas;\r\n    this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this);\r\n\r\n    this.repaintEventNames_ = [\r\n      'mousemove', 'mousedown', 'mouseup',\r\n      'touchstart', 'touchend', 'touchmove',\r\n      'pointerdown', 'pointerup', 'pointermove',\r\n      'wheel'\r\n    ];\r\n\r\n    this.enable();\r\n  }\r\n\r\n  /**\r\n   * Enable.\r\n   */\r\n  enable() {\r\n    this.scene_.requestRenderMode = true;\r\n    this.scene_.maximumRenderTimeChange = 1000;\r\n    for (const repaintKey of this.repaintEventNames_) {\r\n      this.canvas_.addEventListener(repaintKey, this._boundNotifyRepaintRequired, false);\r\n    }\r\n\r\n    window.addEventListener('resize', this._boundNotifyRepaintRequired, false);\r\n\r\n    // Listen for changes on the layer group\r\n    this.ol3d.getOlMap().getLayerGroup().on('change', this._boundNotifyRepaintRequired);\r\n  }\r\n\r\n  /**\r\n   * Disable.\r\n   */\r\n  disable() {\r\n    for (const repaintKey of this.repaintEventNames_) {\r\n      this.canvas_.removeEventListener(repaintKey, this._boundNotifyRepaintRequired, false);\r\n    }\r\n\r\n    window.removeEventListener('resize', this._boundNotifyRepaintRequired, false);\r\n\r\n    this.ol3d.getOlMap().getLayerGroup().un('change', this._boundNotifyRepaintRequired);\r\n    this.scene_.requestRenderMode = false;\r\n  }\r\n\r\n  /**\r\n   * Restart render loop.\r\n   * Force a restart of the render loop.\r\n   * @api\r\n   */\r\n  restartRenderLoop() {\r\n    this.notifyRepaintRequired();\r\n  }\r\n\r\n  notifyRepaintRequired() {\r\n    this.scene_.requestRender();\r\n  }\r\n}\r\n\r\n\r\nexport default AutoRenderLoop;\r\n","/**\r\n * Converts radians to to degrees.\r\n *\r\n * @param {number} angleInRadians Angle in radians.\r\n * @return {number} Angle in degrees.\r\n */\r\nexport function toDegrees(angleInRadians) {\r\n  return angleInRadians * 180 / Math.PI;\r\n}\r\n\r\n\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param {number} angleInDegrees Angle in degrees.\r\n * @return {number} Angle in radians.\r\n */\r\nexport function toRadians(angleInDegrees) {\r\n  return angleInDegrees * Math.PI / 180;\r\n}\r\n","/**\r\n * @module olcs.Camera\r\n */\r\n\r\nimport {unByKey as olObservableUnByKey} from 'ol/Observable.js';\r\nimport {toRadians, toDegrees} from './math.js';\r\nimport {getTransform} from 'ol/proj.js';\r\nimport olcsCore from './core.js';\r\n\r\nclass Camera {\r\n  /**\r\n   * This object takes care of additional 3d-specific properties of the view and\r\n   * ensures proper synchronization with the underlying raw Cesium.Camera object.\r\n   * @param {!Cesium.Scene} scene\r\n   * @param {!ol.Map} map\r\n   * @api\r\n   */\r\n  constructor(scene, map) {\r\n    /**\r\n     * @type {!Cesium.Scene}\r\n     * @private\r\n     */\r\n    this.scene_ = scene;\r\n\r\n    /**\r\n     * @type {!Cesium.Camera}\r\n     * @private\r\n     */\r\n    this.cam_ = scene.camera;\r\n\r\n    /**\r\n     * @type {!ol.Map}\r\n     * @private\r\n     */\r\n    this.map_ = map;\r\n\r\n    /**\r\n     * @type {?ol.View}\r\n     * @private\r\n     */\r\n    this.view_ = null;\r\n\r\n    /**\r\n     * @type {?ol.EventsKey}\r\n     * @private\r\n     */\r\n    this.viewListenKey_ = null;\r\n\r\n    /**\r\n     * @type {!ol.TransformFunction}\r\n     * @private\r\n     */\r\n    this.toLonLat_ = Camera.identityProjection;\r\n\r\n    /**\r\n     * @type {!ol.TransformFunction}\r\n     * @private\r\n     */\r\n    this.fromLonLat_ = Camera.identityProjection;\r\n\r\n    /**\r\n     * 0 -- topdown, PI/2 -- the horizon\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.tilt_ = 0;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.distance_ = 0;\r\n\r\n    /**\r\n     * @type {?Cesium.Matrix4}\r\n     * @private\r\n     */\r\n    this.lastCameraViewMatrix_ = null;\r\n\r\n    /**\r\n     * This is used to discard change events on view caused by updateView method.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.viewUpdateInProgress_ = false;\r\n\r\n    this.map_.on('change:view', (e) => {\r\n      this.setView_(this.map_.getView());\r\n    });\r\n    this.setView_(this.map_.getView());\r\n  }\r\n\r\n  /**\r\n   * @param {Array.<number>} input Input coordinate array.\r\n   * @param {Array.<number>=} opt_output Output array of coordinate values.\r\n   * @param {number=} opt_dimension Dimension.\r\n   * @return {Array.<number>} Input coordinate array (same array as input).\r\n   */\r\n  static identityProjection(input, opt_output, opt_dimension) {\r\n    const dim = opt_dimension || input.length;\r\n    if (opt_output) {\r\n      for (let i = 0; i < dim; ++i) {\r\n        opt_output[i] = input[i];\r\n      }\r\n    }\r\n    return input;\r\n  }\r\n\r\n  /**\r\n   * @param {?ol.View} view New view to use.\r\n   * @private\r\n   */\r\n  setView_(view) {\r\n    if (this.view_) {\r\n      olObservableUnByKey(this.viewListenKey_);\r\n      this.viewListenKey_ = null;\r\n    }\r\n\r\n    this.view_ = view;\r\n    if (view) {\r\n      const toLonLat = getTransform(view.getProjection(), 'EPSG:4326');\r\n      const fromLonLat = getTransform('EPSG:4326', view.getProjection());\r\n      console.assert(toLonLat && fromLonLat);\r\n\r\n      this.toLonLat_ = toLonLat;\r\n      this.fromLonLat_ = fromLonLat;\r\n\r\n      this.viewListenKey_ = view.on('propertychange', e => this.handleViewEvent_(e));\r\n\r\n      this.readFromView();\r\n    } else {\r\n      this.toLonLat_ = Camera.identityProjection;\r\n      this.fromLonLat_ = Camera.identityProjection;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {?} e\r\n   * @private\r\n   */\r\n  handleViewEvent_(e) {\r\n    if (!this.viewUpdateInProgress_) {\r\n      this.readFromView();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} heading In radians.\r\n   * @api\r\n   */\r\n  setHeading(heading) {\r\n    if (!this.view_) {\r\n      return;\r\n    }\r\n\r\n    this.view_.setRotation(heading);\r\n  }\r\n\r\n  /**\r\n   * @return {number|undefined} Heading in radians.\r\n   * @api\r\n   */\r\n  getHeading() {\r\n    if (!this.view_) {\r\n      return undefined;\r\n    }\r\n    const rotation = this.view_.getRotation();\r\n    return rotation || 0;\r\n  }\r\n\r\n  /**\r\n   * @param {number} tilt In radians.\r\n   * @api\r\n   */\r\n  setTilt(tilt) {\r\n    this.tilt_ = tilt;\r\n    this.updateCamera_();\r\n  }\r\n\r\n  /**\r\n   * @return {number} Tilt in radians.\r\n   * @api\r\n   */\r\n  getTilt() {\r\n    return this.tilt_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} distance In meters.\r\n   * @api\r\n   */\r\n  setDistance(distance) {\r\n    this.distance_ = distance;\r\n    this.updateCamera_();\r\n    this.updateView();\r\n  }\r\n\r\n  /**\r\n   * @return {number} Distance in meters.\r\n   * @api\r\n   */\r\n  getDistance() {\r\n    return this.distance_;\r\n  }\r\n\r\n  /**\r\n   * Shortcut for ol.View.setCenter().\r\n   * @param {!ol.Coordinate} center Same projection as the ol.View.\r\n   * @api\r\n   */\r\n  setCenter(center) {\r\n    if (!this.view_) {\r\n      return;\r\n    }\r\n    this.view_.setCenter(center);\r\n  }\r\n\r\n  /**\r\n   * Shortcut for ol.View.getCenter().\r\n   * @return {ol.Coordinate|undefined} Same projection as the ol.View.\r\n   * @api\r\n   */\r\n  getCenter() {\r\n    if (!this.view_) {\r\n      return undefined;\r\n    }\r\n    return this.view_.getCenter();\r\n  }\r\n\r\n  /**\r\n   * Sets the position of the camera.\r\n   * @param {!ol.Coordinate} position Same projection as the ol.View.\r\n   * @api\r\n   */\r\n  setPosition(position) {\r\n    if (!this.toLonLat_) {\r\n      return;\r\n    }\r\n    const ll = this.toLonLat_(position);\r\n    console.assert(ll);\r\n\r\n    const carto = new Cesium.Cartographic(\r\n        toRadians(ll[0]),\r\n        toRadians(ll[1]),\r\n        this.getAltitude());\r\n\r\n    this.cam_.setView({\r\n      destination: Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto)\r\n    });\r\n    this.updateView();\r\n  }\r\n\r\n  /**\r\n   * Calculates position under the camera.\r\n   * @return {!ol.Coordinate|undefined} Same projection as the ol.View.\r\n   * @api\r\n   */\r\n  getPosition() {\r\n    if (!this.fromLonLat_) {\r\n      return undefined;\r\n    }\r\n    const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);\r\n\r\n    const pos = this.fromLonLat_([\r\n      toDegrees(carto.longitude),\r\n      toDegrees(carto.latitude)\r\n    ]);\r\n    console.assert(pos);\r\n    return pos;\r\n  }\r\n\r\n  /**\r\n   * @param {number} altitude In meters.\r\n   * @api\r\n   */\r\n  setAltitude(altitude) {\r\n    const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(\r\n        this.cam_.position);\r\n    carto.height = altitude;\r\n    this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\r\n\r\n    this.updateView();\r\n  }\r\n\r\n  /**\r\n   * @return {number} Altitude in meters.\r\n   * @api\r\n   */\r\n  getAltitude() {\r\n    const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(\r\n        this.cam_.position);\r\n\r\n    return carto.height;\r\n  }\r\n\r\n  /**\r\n   * Updates the state of the underlying Cesium.Camera\r\n   * according to the current values of the properties.\r\n   * @private\r\n   */\r\n  updateCamera_() {\r\n    if (!this.view_ || !this.toLonLat_) {\r\n      return;\r\n    }\r\n    const center = this.view_.getCenter();\r\n    if (!center) {\r\n      return;\r\n    }\r\n    const ll = this.toLonLat_(center);\r\n    console.assert(ll);\r\n\r\n    const carto = new Cesium.Cartographic(toRadians(ll[0]),\r\n        toRadians(ll[1]));\r\n    if (this.scene_.globe) {\r\n      const height = this.scene_.globe.getHeight(carto);\r\n      carto.height = height || 0;\r\n    }\r\n\r\n    const destination = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\r\n\r\n    /** @type {Cesium.optionsOrientation} */\r\n    const orientation = {\r\n      pitch: this.tilt_ - Cesium.Math.PI_OVER_TWO,\r\n      heading: -this.view_.getRotation(),\r\n      roll: undefined\r\n    };\r\n    this.cam_.setView({\r\n      destination,\r\n      orientation\r\n    });\r\n\r\n    this.cam_.moveBackward(this.distance_);\r\n\r\n    this.checkCameraChange(true);\r\n  }\r\n\r\n  /**\r\n   * Calculates the values of the properties from the current ol.View state.\r\n   * @api\r\n   */\r\n  readFromView() {\r\n    if (!this.view_ || !this.toLonLat_) {\r\n      return;\r\n    }\r\n    const center = this.view_.getCenter();\r\n    if (center === undefined || center === null) {\r\n      return;\r\n    }\r\n    const ll = this.toLonLat_(center);\r\n    console.assert(ll);\r\n\r\n    const resolution = this.view_.getResolution();\r\n    this.distance_ = this.calcDistanceForResolution(\r\n        resolution || 0, toRadians(ll[1]));\r\n\r\n    this.updateCamera_();\r\n  }\r\n\r\n  /**\r\n   * Calculates the values of the properties from the current Cesium.Camera state.\r\n   * Modifies the center, resolution and rotation properties of the view.\r\n   * @api\r\n   */\r\n  updateView() {\r\n    if (!this.view_ || !this.fromLonLat_) {\r\n      return;\r\n    }\r\n    this.viewUpdateInProgress_ = true;\r\n\r\n    // target & distance\r\n    const ellipsoid = Cesium.Ellipsoid.WGS84;\r\n    const scene = this.scene_;\r\n    const target = olcsCore.pickCenterPoint(scene);\r\n\r\n    let bestTarget = target;\r\n    if (!bestTarget) {\r\n      //TODO: how to handle this properly ?\r\n      const globe = scene.globe;\r\n      const carto = this.cam_.positionCartographic.clone();\r\n      const height = globe.getHeight(carto);\r\n      carto.height = height || 0;\r\n      bestTarget = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\r\n    }\r\n    this.distance_ = Cesium.Cartesian3.distance(bestTarget, this.cam_.position);\r\n    const bestTargetCartographic = ellipsoid.cartesianToCartographic(bestTarget);\r\n    this.view_.setCenter(this.fromLonLat_([\r\n      toDegrees(bestTargetCartographic.longitude),\r\n      toDegrees(bestTargetCartographic.latitude)]));\r\n\r\n    // resolution\r\n    this.view_.setResolution(\r\n        this.calcResolutionForDistance(this.distance_,\r\n            bestTargetCartographic ? bestTargetCartographic.latitude : 0));\r\n\r\n\r\n    /*\r\n     * Since we are positioning the target, the values of heading and tilt\r\n     * need to be calculated _at the target_.\r\n     */\r\n    if (target) {\r\n      const pos = this.cam_.position;\r\n\r\n      // normal to the ellipsoid at the target\r\n      const targetNormal = new Cesium.Cartesian3();\r\n      ellipsoid.geocentricSurfaceNormal(target, targetNormal);\r\n\r\n      // vector from the target to the camera\r\n      const targetToCamera = new Cesium.Cartesian3();\r\n      Cesium.Cartesian3.subtract(pos, target, targetToCamera);\r\n      Cesium.Cartesian3.normalize(targetToCamera, targetToCamera);\r\n\r\n\r\n      // HEADING\r\n      const up = this.cam_.up;\r\n      const right = this.cam_.right;\r\n      const normal = new Cesium.Cartesian3(-target.y, target.x, 0); // what is it?\r\n      const heading = Cesium.Cartesian3.angleBetween(right, normal);\r\n      const cross = Cesium.Cartesian3.cross(target, up, new Cesium.Cartesian3());\r\n      const orientation = cross.z;\r\n\r\n      this.view_.setRotation((orientation < 0 ? heading : -heading));\r\n\r\n      // TILT\r\n      const tiltAngle = Math.acos(\r\n          Cesium.Cartesian3.dot(targetNormal, targetToCamera));\r\n      this.tilt_ = isNaN(tiltAngle) ? 0 : tiltAngle;\r\n    } else {\r\n      // fallback when there is no target\r\n      this.view_.setRotation(this.cam_.heading);\r\n      this.tilt_ = -this.cam_.pitch + Math.PI / 2;\r\n    }\r\n\r\n    this.viewUpdateInProgress_ = false;\r\n  }\r\n\r\n  /**\r\n   * Check if the underlying camera state has changed and ensure synchronization.\r\n   * @param {boolean=} opt_dontSync Do not synchronize the view.\r\n   */\r\n  checkCameraChange(opt_dontSync) {\r\n    const old = this.lastCameraViewMatrix_;\r\n    const current = this.cam_.viewMatrix;\r\n\r\n    if (!old || !Cesium.Matrix4.equalsEpsilon(old, current, 1e-5)) {\r\n      this.lastCameraViewMatrix_ = current.clone();\r\n      if (opt_dontSync !== true) {\r\n        this.updateView();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * calculate the distance between camera and centerpoint based on the resolution and latitude value\r\n   * @param {number} resolution Number of map units per pixel.\r\n   * @param {number} latitude Latitude in radians.\r\n   * @return {number} The calculated distance.\r\n   * @api\r\n   */\r\n  calcDistanceForResolution(resolution, latitude) {\r\n    const canvas = this.scene_.canvas;\r\n    const fovy = this.cam_.frustum.fovy; // vertical field of view\r\n    console.assert(!isNaN(fovy));\r\n    const metersPerUnit = this.view_.getProjection().getMetersPerUnit();\r\n\r\n    // number of \"map units\" visible in 2D (vertically)\r\n    const visibleMapUnits = resolution * canvas.clientHeight;\r\n\r\n    // The metersPerUnit does not take latitude into account, but it should\r\n    // be lower with increasing latitude -- we have to compensate.\r\n    // In 3D it is not possible to maintain the resolution at more than one point,\r\n    // so it only makes sense to use the latitude of the \"target\" point.\r\n    const relativeCircumference = Math.cos(Math.abs(latitude));\r\n\r\n    // how many meters should be visible in 3D\r\n    const visibleMeters = visibleMapUnits * metersPerUnit * relativeCircumference;\r\n\r\n    // distance required to view the calculated length in meters\r\n    //\r\n    //  fovy/2\r\n    //    |\\\r\n    //  x | \\\r\n    //    |--\\\r\n    // visibleMeters/2\r\n    const requiredDistance = (visibleMeters / 2) / Math.tan(fovy / 2);\r\n\r\n    // NOTE: This calculation is not absolutely precise, because metersPerUnit\r\n    // is a great simplification. It does not take ellipsoid/terrain into account.\r\n\r\n    return requiredDistance;\r\n  }\r\n\r\n  /**\r\n   * calculate the resolution based on a distance(camera to position) and latitude value\r\n   * @param {number} distance\r\n   * @param {number} latitude\r\n   * @return {number} The calculated resolution.\r\n   * @api\r\n   */\r\n  calcResolutionForDistance(distance, latitude) {\r\n    // See the reverse calculation (calcDistanceForResolution) for details\r\n    const canvas = this.scene_.canvas;\r\n    const fovy = this.cam_.frustum.fovy;\r\n    const metersPerUnit = this.view_.getProjection().getMetersPerUnit();\r\n\r\n    const visibleMeters = 2 * distance * Math.tan(fovy / 2);\r\n    const relativeCircumference = Math.cos(Math.abs(latitude));\r\n    const visibleMapUnits = visibleMeters / metersPerUnit / relativeCircumference;\r\n    const resolution = visibleMapUnits / canvas.clientHeight;\r\n\r\n    return resolution;\r\n  }\r\n}\r\n\r\n\r\nexport default Camera;\r\n","/**\r\n * @module olcs.AbstractSynchronizer\r\n */\r\nimport {unByKey as olObservableUnByKey} from 'ol/Observable.js';\r\nimport olLayerGroup from 'ol/layer/Group.js';\r\nimport {olcsListen, getUid} from './util.js';\r\n\r\n\r\nclass AbstractSynchronizer {\r\n  /**\r\n   * @param {!ol.Map} map\r\n   * @param {!Cesium.Scene} scene\r\n   * @template T\r\n   * @abstract\r\n   * @api\r\n   */\r\n  constructor(map, scene) {\r\n    /**\r\n     * @type {!ol.Map}\r\n     * @protected\r\n     */\r\n    this.map = map;\r\n\r\n    /**\r\n     * @type {ol.View}\r\n     * @protected\r\n     */\r\n    this.view = map.getView();\r\n\r\n    /**\r\n     * @type {!Cesium.Scene}\r\n     * @protected\r\n     */\r\n    this.scene = scene;\r\n\r\n    /**\r\n     * @type {ol.Collection.<ol.layer.Base>}\r\n     * @protected\r\n     */\r\n    this.olLayers = map.getLayerGroup().getLayers();\r\n\r\n    /**\r\n     * @type {ol.layer.Group}\r\n     */\r\n    this.mapLayerGroup = map.getLayerGroup();\r\n\r\n    /**\r\n     * Map of OpenLayers layer ids (from getUid) to the Cesium ImageryLayers.\r\n     * Null value means, that we are unable to create equivalent layers.\r\n     * @type {Object.<string, ?Array.<T>>}\r\n     * @protected\r\n     */\r\n    this.layerMap = {};\r\n\r\n    /**\r\n     * Map of listen keys for OpenLayers layer layers ids (from getUid).\r\n     * @type {!Object.<string, Array<ol.EventsKey>>}\r\n     * @protected\r\n     */\r\n    this.olLayerListenKeys = {};\r\n\r\n    /**\r\n     * Map of listen keys for OpenLayers layer groups ids (from getUid).\r\n     * @type {!Object.<string, !Array.<ol.EventsKey>>}\r\n     * @private\r\n     */\r\n    this.olGroupListenKeys_ = {};\r\n  }\r\n\r\n  /**\r\n   * Destroy all and perform complete synchronization of the layers.\r\n   * @api\r\n   */\r\n  synchronize() {\r\n    this.destroyAll();\r\n    this.addLayers_(this.mapLayerGroup);\r\n  }\r\n\r\n  /**\r\n   * Order counterparts using the same algorithm as the Openlayers renderer:\r\n   * z-index then original sequence order.\r\n   * @protected\r\n   */\r\n  orderLayers() {\r\n    // Ordering logics is handled in subclasses.\r\n  }\r\n\r\n  /**\r\n   * Add a layer hierarchy.\r\n   * @param {ol.layer.Base} root\r\n   * @private\r\n   */\r\n  addLayers_(root) {\r\n    /** @type {Array<import('olsc/core.js').LayerWithParents>} */\r\n    const fifo = [{\r\n      layer: root,\r\n      parents: []\r\n    }];\r\n    while (fifo.length > 0) {\r\n      const olLayerWithParents = fifo.splice(0, 1)[0];\r\n      const olLayer = olLayerWithParents.layer;\r\n      const olLayerId = getUid(olLayer).toString();\r\n      this.olLayerListenKeys[olLayerId] = [];\r\n      console.assert(!this.layerMap[olLayerId]);\r\n\r\n      let cesiumObjects = null;\r\n      if (olLayer instanceof olLayerGroup) {\r\n        this.listenForGroupChanges_(olLayer);\r\n        if (olLayer !== this.mapLayerGroup) {\r\n          cesiumObjects = this.createSingleLayerCounterparts(olLayerWithParents);\r\n        }\r\n        if (!cesiumObjects) {\r\n          olLayer.getLayers().forEach((l) => {\r\n            if (l) {\r\n              const newOlLayerWithParents = {\r\n                layer: l,\r\n                parents: olLayer === this.mapLayerGroup ?\r\n                  [] :\r\n                  [olLayerWithParents.layer].concat(olLayerWithParents.parents)\r\n              };\r\n              fifo.push(newOlLayerWithParents);\r\n            }\r\n          });\r\n        }\r\n      } else {\r\n        cesiumObjects = this.createSingleLayerCounterparts(olLayerWithParents);\r\n        if (!cesiumObjects) {\r\n          // keep an eye on the layers that once failed to be added (might work when the layer is updated)\r\n          // for example when a source is set after the layer is added to the map\r\n          const layerId = olLayerId;\r\n          const layerWithParents = olLayerWithParents;\r\n          const onLayerChange = (e) => {\r\n            const cesiumObjs = this.createSingleLayerCounterparts(layerWithParents);\r\n            if (cesiumObjs) {\r\n              // unsubscribe event listener\r\n              layerWithParents.layer.un('change', onLayerChange);\r\n              this.addCesiumObjects_(cesiumObjs, layerId, layerWithParents.layer);\r\n              this.orderLayers();\r\n            }\r\n          };\r\n          this.olLayerListenKeys[olLayerId].push(olcsListen(layerWithParents.layer, 'change', onLayerChange));\r\n        }\r\n      }\r\n      // add Cesium layers\r\n      if (cesiumObjects) {\r\n        this.addCesiumObjects_(cesiumObjects, olLayerId, olLayer);\r\n      }\r\n    }\r\n\r\n    this.orderLayers();\r\n  }\r\n\r\n  /**\r\n   * Add Cesium objects.\r\n   * @param {Array.<T>} cesiumObjects\r\n   * @param {string} layerId\r\n   * @param {ol.layer.Base} layer\r\n   * @private\r\n   */\r\n  addCesiumObjects_(cesiumObjects, layerId, layer) {\r\n    this.layerMap[layerId] = cesiumObjects;\r\n    this.olLayerListenKeys[layerId].push(olcsListen(layer, 'change:zIndex', () => this.orderLayers()));\r\n    cesiumObjects.forEach((cesiumObject) => {\r\n      this.addCesiumObject(cesiumObject);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove and destroy a single layer.\r\n   * @param {ol.layer.Layer} layer\r\n   * @return {boolean} counterpart destroyed\r\n   * @private\r\n   */\r\n  removeAndDestroySingleLayer_(layer) {\r\n    const uid = getUid(layer).toString();\r\n    const counterparts = this.layerMap[uid];\r\n    if (!!counterparts) {\r\n      counterparts.forEach((counterpart) => {\r\n        this.removeSingleCesiumObject(counterpart, false);\r\n        this.destroyCesiumObject(counterpart);\r\n      });\r\n      this.olLayerListenKeys[uid].forEach(olObservableUnByKey);\r\n      delete this.olLayerListenKeys[uid];\r\n    }\r\n    delete this.layerMap[uid];\r\n    return !!counterparts;\r\n  }\r\n\r\n  /**\r\n   * Unlisten a single layer group.\r\n   * @param {ol.layer.Group} group\r\n   * @private\r\n   */\r\n  unlistenSingleGroup_(group) {\r\n    if (group === this.mapLayerGroup) {\r\n      return;\r\n    }\r\n    const uid = getUid(group).toString();\r\n    const keys = this.olGroupListenKeys_[uid];\r\n    keys.forEach((key) => {\r\n      olObservableUnByKey(key);\r\n    });\r\n    delete this.olGroupListenKeys_[uid];\r\n    delete this.layerMap[uid];\r\n  }\r\n\r\n  /**\r\n   * Remove layer hierarchy.\r\n   * @param {ol.layer.Base} root\r\n   * @private\r\n   */\r\n  removeLayer_(root) {\r\n    if (!!root) {\r\n      const fifo = [root];\r\n      while (fifo.length > 0) {\r\n        const olLayer = fifo.splice(0, 1)[0];\r\n        const done = this.removeAndDestroySingleLayer_(olLayer);\r\n        if (olLayer instanceof olLayerGroup) {\r\n          this.unlistenSingleGroup_(olLayer);\r\n          if (!done) {\r\n            // No counterpart for the group itself so removing\r\n            // each of the child layers.\r\n            olLayer.getLayers().forEach((l) => {\r\n              fifo.push(l);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register listeners for single layer group change.\r\n   * @param {ol.layer.Group} group\r\n   * @private\r\n   */\r\n  listenForGroupChanges_(group) {\r\n    const uuid = getUid(group).toString();\r\n\r\n    console.assert(this.olGroupListenKeys_[uuid] === undefined);\r\n\r\n    const listenKeyArray = [];\r\n    this.olGroupListenKeys_[uuid] = listenKeyArray;\r\n\r\n    // only the keys that need to be relistened when collection changes\r\n    let contentKeys = [];\r\n    const listenAddRemove = (function() {\r\n      const collection = group.getLayers();\r\n      if (collection) {\r\n        contentKeys = [\r\n          collection.on('add', (event) => {\r\n            this.addLayers_(event.element);\r\n          }),\r\n          collection.on('remove', (event) => {\r\n            this.removeLayer_(event.element);\r\n          })\r\n        ];\r\n        listenKeyArray.push(...contentKeys);\r\n      }\r\n    }).bind(this);\r\n\r\n    listenAddRemove();\r\n\r\n    listenKeyArray.push(group.on('change:layers', (e) => {\r\n      contentKeys.forEach((el) => {\r\n        const i = listenKeyArray.indexOf(el);\r\n        if (i >= 0) {\r\n          listenKeyArray.splice(i, 1);\r\n        }\r\n        olObservableUnByKey(el);\r\n      });\r\n      listenAddRemove();\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Destroys all the created Cesium objects.\r\n   * @protected\r\n   */\r\n  destroyAll() {\r\n    this.removeAllCesiumObjects(true); // destroy\r\n    let objKey;\r\n    for (objKey in this.olGroupListenKeys_) {\r\n      const keys = this.olGroupListenKeys_[objKey];\r\n      keys.forEach(olObservableUnByKey);\r\n    }\r\n    for (objKey in this.olLayerListenKeys) {\r\n      this.olLayerListenKeys[objKey].forEach(olObservableUnByKey);\r\n    }\r\n    this.olGroupListenKeys_ = {};\r\n    this.olLayerListenKeys = {};\r\n    this.layerMap = {};\r\n  }\r\n\r\n  /**\r\n   * Adds a single Cesium object to the collection.\r\n   * @param {!T} object\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  addCesiumObject(object) {}\r\n\r\n  /**\r\n   * @param {!T} object\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  destroyCesiumObject(object) {}\r\n\r\n  /**\r\n   * Remove single Cesium object from the collection.\r\n   * @param {!T} object\r\n   * @param {boolean} destroy\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  removeSingleCesiumObject(object, destroy) {}\r\n\r\n  /**\r\n   * Remove all Cesium objects from the collection.\r\n   * @param {boolean} destroy\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  removeAllCesiumObjects(destroy) {}\r\n\r\n  /**\r\n   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents\r\n   * @return {?Array.<T>}\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  createSingleLayerCounterparts(olLayerWithParents) {}\r\n}\r\n\r\n\r\nexport default AbstractSynchronizer;\r\n","/**\r\n * @module olcs.RasterSynchronizer\r\n */\r\nimport olLayerGroup from 'ol/layer/Group.js';\r\nimport {getUid, stableSort} from './util.js';\r\nimport olcsAbstractSynchronizer from './AbstractSynchronizer.js';\r\nimport olcsCore from './core.js';\r\n\r\nclass RasterSynchronizer extends olcsAbstractSynchronizer {\r\n  /**\r\n   * This object takes care of one-directional synchronization of\r\n   * Openlayers raster layers to the given Cesium globe.\r\n   * @param {!ol.Map} map\r\n   * @param {!Cesium.Scene} scene\r\n   * @constructor\r\n   * @extends {olcsAbstractSynchronizer.<Cesium.ImageryLayer>}\r\n   * @api\r\n   */\r\n  constructor(map, scene) {\r\n    super(map, scene);\r\n\r\n    /**\r\n     * @type {!Cesium.ImageryLayerCollection}\r\n     * @private\r\n     */\r\n    this.cesiumLayers_ = scene.imageryLayers;\r\n\r\n    /**\r\n     * @type {!Cesium.ImageryLayerCollection}\r\n     * @private\r\n     */\r\n    this.ourLayers_ = new Cesium.ImageryLayerCollection();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  addCesiumObject(object) {\r\n    this.cesiumLayers_.add(object);\r\n    this.ourLayers_.add(object);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  destroyCesiumObject(object) {\r\n    object.destroy();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  removeSingleCesiumObject(object, destroy) {\r\n    this.cesiumLayers_.remove(object, destroy);\r\n    this.ourLayers_.remove(object, false);\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  removeAllCesiumObjects(destroy) {\r\n    for (let i = 0; i < this.ourLayers_.length; ++i) {\r\n      this.cesiumLayers_.remove(this.ourLayers_.get(i), destroy);\r\n    }\r\n    this.ourLayers_.removeAll(false);\r\n  }\r\n\r\n  /**\r\n   * Creates an array of Cesium.ImageryLayer.\r\n   * May be overriden by child classes to implement custom behavior.\r\n   * The default implementation handles tiled imageries in EPSG:4326 or\r\n   * EPSG:3859.\r\n   * @param {!ol.layer.Base} olLayer\r\n   * @param {!ol.proj.Projection} viewProj Projection of the view.\r\n   * @return {?Array.<!Cesium.ImageryLayer>} array or null if not possible\r\n   * (or supported)\r\n   * @protected\r\n   */\r\n  convertLayerToCesiumImageries(olLayer, viewProj) {\r\n    const result = olcsCore.tileLayerToImageryLayer(this.map, olLayer, viewProj);\r\n    return result ? [result] : null;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  createSingleLayerCounterparts(olLayerWithParents) {\r\n    const olLayer = olLayerWithParents.layer;\r\n    const uid = getUid(olLayer).toString();\r\n    const viewProj = this.view.getProjection();\r\n    console.assert(viewProj);\r\n    const cesiumObjects = this.convertLayerToCesiumImageries(olLayer, viewProj);\r\n    if (cesiumObjects) {\r\n      const listenKeyArray = [];\r\n      [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayerItem) => {\r\n        listenKeyArray.push(olLayerItem.on(['change:opacity', 'change:visible'], () => {\r\n          // the compiler does not seem to be able to infer this\r\n          console.assert(cesiumObjects);\r\n          for (let i = 0; i < cesiumObjects.length; ++i) {\r\n            olcsCore.updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);\r\n          }\r\n        }));\r\n      });\r\n\r\n      for (let i = 0; i < cesiumObjects.length; ++i) {\r\n        olcsCore.updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);\r\n      }\r\n\r\n      // there is no way to modify Cesium layer extent,\r\n      // we have to recreate when OpenLayers layer extent changes:\r\n      listenKeyArray.push(olLayer.on('change:extent', (e) => {\r\n        for (let i = 0; i < cesiumObjects.length; ++i) {\r\n          this.cesiumLayers_.remove(cesiumObjects[i], true); // destroy\r\n          this.ourLayers_.remove(cesiumObjects[i], false);\r\n        }\r\n        delete this.layerMap[getUid(olLayer)]; // invalidate the map entry\r\n        this.synchronize();\r\n      }));\r\n\r\n      listenKeyArray.push(olLayer.on('change', (e) => {\r\n        // when the source changes, re-add the layer to force update\r\n        for (let i = 0; i < cesiumObjects.length; ++i) {\r\n          const position = this.cesiumLayers_.indexOf(cesiumObjects[i]);\r\n          if (position >= 0) {\r\n            this.cesiumLayers_.remove(cesiumObjects[i], false);\r\n            this.cesiumLayers_.add(cesiumObjects[i], position);\r\n          }\r\n        }\r\n      }));\r\n\r\n      this.olLayerListenKeys[uid].push(...listenKeyArray);\r\n    }\r\n\r\n    return Array.isArray(cesiumObjects) ? cesiumObjects : null;\r\n  }\r\n\r\n  /**\r\n   * Order counterparts using the same algorithm as the Openlayers renderer:\r\n   * z-index then original sequence order.\r\n   * @override\r\n   * @protected\r\n   */\r\n  orderLayers() {\r\n    const layers = [];\r\n    const zIndices = {};\r\n    const queue = [this.mapLayerGroup];\r\n\r\n    while (queue.length > 0) {\r\n      const olLayer = queue.splice(0, 1)[0];\r\n      layers.push(olLayer);\r\n      zIndices[getUid(olLayer)] = olLayer.getZIndex();\r\n\r\n      if (olLayer instanceof olLayerGroup) {\r\n        const sublayers = olLayer.getLayers();\r\n        if (sublayers) {\r\n          // Prepend queue with sublayers in order\r\n          queue.unshift(...sublayers.getArray());\r\n        }\r\n      }\r\n    }\r\n\r\n    stableSort(layers, (layer1, layer2) =>\r\n      zIndices[getUid(layer1)] - zIndices[getUid(layer2)]\r\n    );\r\n\r\n    layers.forEach((olLayer) => {\r\n      const olLayerId = getUid(olLayer).toString();\r\n      const cesiumObjects = this.layerMap[olLayerId];\r\n      if (cesiumObjects) {\r\n        cesiumObjects.forEach((cesiumObject) => { this.raiseToTop(cesiumObject); });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {Cesium.ImageryLayer} counterpart\r\n   */\r\n  raiseToTop(counterpart) {\r\n    this.cesiumLayers_.raiseToTop(counterpart);\r\n  }\r\n}\r\n\r\n\r\nexport default RasterSynchronizer;\r\n","/**\r\n * @module olcs.core.VectorLayerCounterpart\r\n */\r\nimport {unByKey as olObservableUnByKey} from 'ol/Observable.js';\r\n\r\n\r\n/**\r\n * Context for feature conversion.\r\n * @typedef {Object} OlFeatureToCesiumContext\r\n * @property {!(import('ol/Projection.js').default|string)} projection\r\n * @property {!Cesium.PrimitiveCollection} primitives\r\n * @property {Object<number, Array<!Cesium.Primitive|!Cesium.Billboard>>} featureToCesiumMap\r\n * @property {!Cesium.BillboardCollection} billboards\r\n */\r\n\r\n\r\nclass VectorLayerCounterpart {\r\n  /**\r\n  * Result of the conversion of an OpenLayers layer to Cesium.\r\n  * @param {!(ol.proj.Projection|string)} layerProjection\r\n  * @param {!Cesium.Scene} scene\r\n  */\r\n  constructor(layerProjection, scene) {\r\n    const billboards = new Cesium.BillboardCollection({scene});\r\n    const primitives = new Cesium.PrimitiveCollection();\r\n\r\n    /**\r\n    * @type {!Array.<ol.EventsKey>}\r\n    */\r\n    this.olListenKeys = [];\r\n\r\n    this.rootCollection_ = new Cesium.PrimitiveCollection();\r\n    /**\r\n    * @type {!OlFeatureToCesiumContext}\r\n    */\r\n    this.context = {\r\n      projection: layerProjection,\r\n      billboards,\r\n      featureToCesiumMap: {},\r\n      primitives\r\n    };\r\n\r\n    this.rootCollection_.add(billboards);\r\n    this.rootCollection_.add(primitives);\r\n  }\r\n\r\n  /**\r\n  * Unlisten.\r\n  */\r\n  destroy() {\r\n    this.olListenKeys.forEach(olObservableUnByKey);\r\n    this.olListenKeys.length = 0;\r\n  }\r\n\r\n  /**\r\n  * @return {!Cesium.Primitive}\r\n  */\r\n  getRootPrimitive() {\r\n    return this.rootCollection_;\r\n  }\r\n}\r\n\r\n\r\nexport default VectorLayerCounterpart;\r\n","/**\r\n * @module olcs.FeatureConverter\r\n */\r\nimport olGeomGeometry from 'ol/geom/Geometry.js';\r\nimport olStyleIcon from 'ol/style/Icon.js';\r\nimport olSourceVector from 'ol/source/Vector.js';\r\nimport olSourceCluster from 'ol/source/Cluster.js';\r\nimport {circular as olCreateCircularPolygon} from 'ol/geom/Polygon.js';\r\nimport {boundingExtent, getCenter} from 'ol/extent.js';\r\nimport olGeomSimpleGeometry from 'ol/geom/SimpleGeometry.js';\r\nimport olcsCore from './core.js';\r\nimport olcsCoreVectorLayerCounterpart from './core/VectorLayerCounterpart.js';\r\nimport olcsUtil, {getUid, isGroundPolylinePrimitiveSupported} from './util.js';\r\n\r\n\r\n/**\r\n * @typedef {Object} ModelStyle\r\n * @property {Cesium.Matrix4} [debugModelMatrix]\r\n * @property {Cesium.ModelFromGltfOptions} cesiumOptions\r\n */\r\n\r\n\r\nclass FeatureConverter {\r\n  /**\r\n   * Concrete base class for converting from OpenLayers3 vectors to Cesium\r\n   * primitives.\r\n   * Extending this class is possible provided that the extending class and\r\n   * the library are compiled together by the closure compiler.\r\n   * @param {!Cesium.Scene} scene Cesium scene.\r\n   * @constructor\r\n   * @api\r\n   */\r\n  constructor(scene) {\r\n\r\n    /**\r\n     * @protected\r\n     */\r\n    this.scene = scene;\r\n\r\n    /**\r\n     * Bind once to have a unique function for using as a listener\r\n     * @type {function(ol.source.Vector.Event)}\r\n     * @private\r\n     */\r\n    this.boundOnRemoveOrClearFeatureListener_ = this.onRemoveOrClearFeature_.bind(this);\r\n\r\n    /**\r\n     * @type {Cesium.Cartesian3}\r\n     * @private\r\n     */\r\n    this.defaultBillboardEyeOffset_ = new Cesium.Cartesian3(0, 0, 10);\r\n  }\r\n\r\n  /**\r\n   * @param {ol.source.Vector.Event} evt\r\n   * @private\r\n   */\r\n  onRemoveOrClearFeature_(evt) {\r\n    const source = evt.target;\r\n    console.assert(source instanceof olSourceVector);\r\n\r\n    const cancellers = olcsUtil.obj(source)['olcs_cancellers'];\r\n    if (cancellers) {\r\n      const feature = evt.feature;\r\n      if (feature) {\r\n        // remove\r\n        const id = getUid(feature);\r\n        const canceller = cancellers[id];\r\n        if (canceller) {\r\n          canceller();\r\n          delete cancellers[id];\r\n        }\r\n      } else {\r\n        // clear\r\n        for (const key in cancellers) {\r\n          if (cancellers.hasOwnProperty(key)) {\r\n            cancellers[key]();\r\n          }\r\n        }\r\n        olcsUtil.obj(source)['olcs_cancellers'] = {};\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature.\r\n   * @param {!Cesium.Primitive|Cesium.Label|Cesium.Billboard} primitive\r\n   * @protected\r\n   */\r\n  setReferenceForPicking(layer, feature, primitive) {\r\n    primitive.olLayer = layer;\r\n    primitive.olFeature = feature;\r\n  }\r\n\r\n  /**\r\n   * Basics primitive creation using a color attribute.\r\n   * Note that Cesium has 'interior' and outline geometries.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature.\r\n   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.\r\n   * @param {!Cesium.Geometry} geometry\r\n   * @param {!Cesium.Color} color\r\n   * @param {number=} opt_lineWidth\r\n   * @return {Cesium.Primitive}\r\n   * @protected\r\n   */\r\n  createColoredPrimitive(layer, feature, olGeometry, geometry, color, opt_lineWidth) {\r\n    const createInstance = function(geometry, color) {\r\n      const instance = new Cesium.GeometryInstance({\r\n        // always update Cesium externs before adding a property\r\n        geometry\r\n      });\r\n      if (color && !(color instanceof Cesium.ImageMaterialProperty)) {\r\n        instance.attributes = {\r\n          color: Cesium.ColorGeometryInstanceAttribute.fromColor(color)\r\n        };\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    const options = {\r\n      // always update Cesium externs before adding a property\r\n      flat: true, // work with all geometries\r\n      renderState: {\r\n        depthTest: {\r\n          enabled: true\r\n        }\r\n      }\r\n    };\r\n\r\n    if (opt_lineWidth !== undefined) {\r\n      if (!options.renderState) {\r\n        options.renderState = {};\r\n      }\r\n      options.renderState.lineWidth = opt_lineWidth;\r\n    }\r\n\r\n    const instances = createInstance(geometry, color);\r\n\r\n    const heightReference = this.getHeightReference(layer, feature, olGeometry);\r\n\r\n    let primitive;\r\n\r\n    if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\r\n      const ctor = instances.geometry.constructor;\r\n      if (ctor && !ctor['createShadowVolume']) {\r\n        return null;\r\n      }\r\n      primitive = new Cesium.GroundPrimitive({\r\n        geometryInstances: instances\r\n      });\r\n    } else {\r\n      primitive = new Cesium.Primitive({\r\n        geometryInstances: instances\r\n      });\r\n    }\r\n\r\n    if (color instanceof Cesium.ImageMaterialProperty) {\r\n      const dataUri = color.image.getValue().toDataURL();\r\n\r\n      primitive.appearance = new Cesium.MaterialAppearance({\r\n        flat: true,\r\n        renderState: {\r\n          depthTest: {\r\n            enabled: true\r\n          }\r\n        },\r\n        material: new Cesium.Material({\r\n          fabric: {\r\n            type: 'Image',\r\n            uniforms: {\r\n              image: dataUri\r\n            }\r\n          }\r\n        })\r\n      });\r\n    } else {\r\n      primitive.appearance = new Cesium.PerInstanceColorAppearance(options);\r\n    }\r\n\r\n    this.setReferenceForPicking(layer, feature, primitive);\r\n    return primitive;\r\n  }\r\n\r\n  /**\r\n   * Return the fill or stroke color from a plain ol style.\r\n   * @param {!ol.style.Style|ol.style.Text} style\r\n   * @param {boolean} outline\r\n   * @return {!Cesium.Color}\r\n   * @protected\r\n   */\r\n  extractColorFromOlStyle(style, outline) {\r\n    const fillColor = style.getFill() ? style.getFill().getColor() : null;\r\n    const strokeColor = style.getStroke() ? style.getStroke().getColor() : null;\r\n\r\n    let olColor = 'black';\r\n    if (strokeColor && outline) {\r\n      olColor = strokeColor;\r\n    } else if (fillColor) {\r\n      olColor = fillColor;\r\n    }\r\n\r\n    return olcsCore.convertColorToCesium(olColor);\r\n  }\r\n\r\n  /**\r\n   * Return the width of stroke from a plain ol style.\r\n   * @param {!ol.style.Style|ol.style.Text} style\r\n   * @return {number}\r\n   * @protected\r\n   */\r\n  extractLineWidthFromOlStyle(style) {\r\n    // Handling of line width WebGL limitations is handled by Cesium.\r\n    const width = style.getStroke() ? style.getStroke().getWidth() : undefined;\r\n    return width !== undefined ? width : 1;\r\n  }\r\n\r\n  /**\r\n   * Create a primitive collection out of two Cesium geometries.\r\n   * Only the OpenLayers style colors will be used.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature.\r\n   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.\r\n   * @param {!Cesium.Geometry} fillGeometry\r\n   * @param {!Cesium.Geometry} outlineGeometry\r\n   * @param {!ol.style.Style} olStyle\r\n   * @return {!Cesium.PrimitiveCollection}\r\n   * @protected\r\n   */\r\n  wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle) {\r\n    const fillColor = this.extractColorFromOlStyle(olStyle, false);\r\n    const outlineColor = this.extractColorFromOlStyle(olStyle, true);\r\n\r\n    const primitives = new Cesium.PrimitiveCollection();\r\n    if (olStyle.getFill()) {\r\n      const p1 = this.createColoredPrimitive(layer, feature, olGeometry,\r\n          fillGeometry, fillColor);\r\n      console.assert(!!p1);\r\n      primitives.add(p1);\r\n    }\r\n\r\n    if (olStyle.getStroke() && outlineGeometry) {\r\n      const width = this.extractLineWidthFromOlStyle(olStyle);\r\n      const p2 = this.createColoredPrimitive(layer, feature, olGeometry,\r\n          outlineGeometry, outlineColor, width);\r\n      if (p2) {\r\n        // Some outline geometries are not supported by Cesium in clamp to ground\r\n        // mode. These primitives are skipped.\r\n        primitives.add(p2);\r\n      }\r\n    }\r\n\r\n    return primitives;\r\n  }\r\n\r\n  // Geometry converters\r\n  /**\r\n   * Create a Cesium primitive if style has a text component.\r\n   * Eventually return a PrimitiveCollection including current primitive.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Geometry} geometry\r\n   * @param {!ol.style.Style} style\r\n   * @param {!Cesium.Primitive} primitive current primitive\r\n   * @return {!Cesium.PrimitiveCollection}\r\n   * @protected\r\n   */\r\n  addTextStyle(layer, feature, geometry, style, primitive) {\r\n    let primitives;\r\n    if (!(primitive instanceof Cesium.PrimitiveCollection)) {\r\n      primitives = new Cesium.PrimitiveCollection();\r\n      primitives.add(primitive);\r\n    } else {\r\n      primitives = primitive;\r\n    }\r\n\r\n    if (!style.getText()) {\r\n      return primitives;\r\n    }\r\n\r\n    const text = /** @type {!ol.style.Text} */ (style.getText());\r\n    const label = this.olGeometry4326TextPartToCesium(layer, feature, geometry,\r\n        text);\r\n    if (label) {\r\n      primitives.add(label);\r\n    }\r\n    return primitives;\r\n  }\r\n\r\n  /**\r\n   * Add a billboard to a Cesium.BillboardCollection.\r\n   * Overriding this wrapper allows manipulating the billboard options.\r\n   * @param {!Cesium.BillboardCollection} billboards\r\n   * @param {!Cesium.optionsBillboardCollectionAdd} bbOptions\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature.\r\n   * @param {!ol.geom.Geometry} geometry\r\n   * @param {!ol.style.Style} style\r\n   * @return {!Cesium.Billboard} newly created billboard\r\n   * @api\r\n   */\r\n  csAddBillboard(billboards, bbOptions, layer, feature, geometry, style) {\r\n    if (!bbOptions.eyeOffset) {\r\n      bbOptions.eyeOffset = this.defaultBillboardEyeOffset_;\r\n    }\r\n    const bb = billboards.add(bbOptions);\r\n    this.setReferenceForPicking(layer, feature, bb);\r\n    return bb;\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers circle geometry to Cesium.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Circle} olGeometry OpenLayers circle geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} olStyle\r\n   * @return {!Cesium.PrimitiveCollection} primitives\r\n   * @api\r\n   */\r\n  olCircleGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\r\n\r\n    olGeometry = olcsCore.olGeometryCloneTo4326(olGeometry, projection);\r\n    console.assert(olGeometry.getType() == 'Circle');\r\n\r\n    // ol.Coordinate\r\n    let center = olGeometry.getCenter();\r\n    const height = center.length == 3 ? center[2] : 0.0;\r\n    let point = center.slice();\r\n    point[0] += olGeometry.getRadius();\r\n\r\n    // Cesium\r\n    center = olcsCore.ol4326CoordinateToCesiumCartesian(center);\r\n    point = olcsCore.ol4326CoordinateToCesiumCartesian(point);\r\n\r\n    // Accurate computation of straight distance\r\n    const radius = Cesium.Cartesian3.distance(center, point);\r\n\r\n    const fillGeometry = new Cesium.CircleGeometry({\r\n      // always update Cesium externs before adding a property\r\n      center,\r\n      radius,\r\n      height\r\n    });\r\n\r\n    let outlinePrimitive, outlineGeometry;\r\n    if (this.getHeightReference(layer, feature, olGeometry) === Cesium.HeightReference.CLAMP_TO_GROUND) {\r\n      const width = this.extractLineWidthFromOlStyle(olStyle);\r\n      if (width) {\r\n        const circlePolygon = olCreateCircularPolygon(olGeometry.getCenter(), radius);\r\n        const positions = olcsCore.ol4326CoordinateArrayToCsCartesians(circlePolygon.getLinearRing(0).getCoordinates());\r\n        if (!isGroundPolylinePrimitiveSupported(this.scene)) {\r\n          const color = this.extractColorFromOlStyle(olStyle, true);\r\n          outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\r\n        } else {\r\n          outlinePrimitive = new Cesium.GroundPolylinePrimitive({\r\n            geometryInstances: new Cesium.GeometryInstance({\r\n              geometry: new Cesium.GroundPolylineGeometry({positions, width}),\r\n            }),\r\n            appearance: new Cesium.PolylineMaterialAppearance({\r\n              material: this.olStyleToCesium(feature, olStyle, true),\r\n            }),\r\n            classificationType: Cesium.ClassificationType.TERRAIN,\r\n          });\r\n          outlinePrimitive.readyPromise.then(() => {\r\n            this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      outlineGeometry = new Cesium.CircleOutlineGeometry({\r\n        // always update Cesium externs before adding a property\r\n        center,\r\n        radius,\r\n        extrudedHeight: height,\r\n        height\r\n      });\r\n    }\r\n\r\n    const primitives = this.wrapFillAndOutlineGeometries(\r\n        layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);\r\n\r\n    if (outlinePrimitive) {\r\n      primitives.add(outlinePrimitive);\r\n    }\r\n    return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);\r\n  }\r\n\r\n  /**\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!number} width The width of the line.\r\n   * @param {!Cesium.Color} color The color of the line.\r\n   * @param {!Array<Cesium.Cartesian3>|Array<Array<Cesium.Cartesian3>>} positions The vertices of the line(s).\r\n   * @return {!Cesium.GroundPrimitive} primitive\r\n   */\r\n  createStackedGroundCorridors(layer, feature, width, color, positions) {\r\n    // Convert positions to an Array if it isn't\r\n    if (!Array.isArray(positions[0])) {\r\n      positions = [positions];\r\n    }\r\n    width = Math.max(3, width); // A <3px width is too small for ground primitives\r\n    const geometryInstances = [];\r\n    let previousDistance = 0;\r\n    // A stack of ground lines with increasing width (in meters) are created.\r\n    // Only one of these lines is displayed at any time giving a feeling of continuity.\r\n    // The values for the distance and width factor are more or less arbitrary.\r\n    // Applications can override this logics by subclassing the FeatureConverter class.\r\n    for (const distance of [1000, 4000, 16000, 64000, 254000, 1000000, 10000000]) {\r\n      width *= 2.14;\r\n      const geometryOptions = {\r\n        // always update Cesium externs before adding a property\r\n        width,\r\n        vertexFormat: Cesium.VertexFormat.POSITION_ONLY\r\n      };\r\n      for (const linePositions of positions) {\r\n        geometryOptions.positions = linePositions;\r\n        geometryInstances.push(new Cesium.GeometryInstance({\r\n          geometry: new Cesium.CorridorGeometry(geometryOptions),\r\n          attributes: {\r\n            color: Cesium.ColorGeometryInstanceAttribute.fromColor(color),\r\n            distanceDisplayCondition: new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(previousDistance, distance - 1)\r\n          }\r\n        }));\r\n      }\r\n      previousDistance = distance;\r\n    }\r\n    return new Cesium.GroundPrimitive({\r\n      // always update Cesium externs before adding a property\r\n      geometryInstances\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers line string geometry to Cesium.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.LineString} olGeometry OpenLayers line string geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} olStyle\r\n   * @return {!Cesium.PrimitiveCollection} primitives\r\n   * @api\r\n   */\r\n  olLineStringGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\r\n\r\n    olGeometry = olcsCore.olGeometryCloneTo4326(olGeometry, projection);\r\n    console.assert(olGeometry.getType() == 'LineString');\r\n\r\n    const positions = olcsCore.ol4326CoordinateArrayToCsCartesians(olGeometry.getCoordinates());\r\n    const width = this.extractLineWidthFromOlStyle(olStyle);\r\n\r\n    let outlinePrimitive;\r\n    const heightReference = this.getHeightReference(layer, feature, olGeometry);\r\n\r\n    if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND && !isGroundPolylinePrimitiveSupported(this.scene)) {\r\n      const color = this.extractColorFromOlStyle(olStyle, true);\r\n      outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\r\n    } else {\r\n      const appearance = new Cesium.PolylineMaterialAppearance({\r\n        // always update Cesium externs before adding a property\r\n        material: this.olStyleToCesium(feature, olStyle, true)\r\n      });\r\n      const geometryOptions = {\r\n        // always update Cesium externs before adding a property\r\n        positions,\r\n        width,\r\n      };\r\n      const primitiveOptions = {\r\n        // always update Cesium externs before adding a property\r\n        appearance\r\n      };\r\n      if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\r\n        const geometry = new Cesium.GroundPolylineGeometry(geometryOptions);\r\n        primitiveOptions.geometryInstances = new Cesium.GeometryInstance({\r\n          geometry\r\n        }),\r\n        outlinePrimitive = new Cesium.GroundPolylinePrimitive(primitiveOptions);\r\n        outlinePrimitive.readyPromise.then(() => {\r\n          this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\r\n        });\r\n      } else {\r\n        geometryOptions.vertexFormat = appearance.vertexFormat;\r\n        const geometry = new Cesium.PolylineGeometry(geometryOptions);\r\n        primitiveOptions.geometryInstances = new Cesium.GeometryInstance({\r\n          geometry\r\n        }),\r\n        outlinePrimitive = new Cesium.Primitive(primitiveOptions);\r\n      }\r\n    }\r\n\r\n    this.setReferenceForPicking(layer, feature, outlinePrimitive);\r\n\r\n    return this.addTextStyle(layer, feature, olGeometry, olStyle, outlinePrimitive);\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers polygon geometry to Cesium.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Polygon} olGeometry OpenLayers polygon geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} olStyle\r\n   * @return {!Cesium.PrimitiveCollection} primitives\r\n   * @api\r\n   */\r\n  olPolygonGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\r\n\r\n    olGeometry = olcsCore.olGeometryCloneTo4326(olGeometry, projection);\r\n    console.assert(olGeometry.getType() == 'Polygon');\r\n\r\n    const heightReference = this.getHeightReference(layer, feature, olGeometry);\r\n\r\n    let fillGeometry, outlineGeometry, outlinePrimitive;\r\n    if ((olGeometry.getCoordinates()[0].length == 5) &&\r\n        (feature.getGeometry().get('olcs.polygon_kind') === 'rectangle')) {\r\n      // Create a rectangle according to the longitude and latitude curves\r\n      const coordinates = olGeometry.getCoordinates()[0];\r\n      // Extract the West, South, East, North coordinates\r\n      const extent = boundingExtent(coordinates);\r\n      const rectangle = Cesium.Rectangle.fromDegrees(extent[0], extent[1],\r\n          extent[2], extent[3]);\r\n\r\n      // Extract the average height of the vertices\r\n      let maxHeight = 0.0;\r\n      if (coordinates[0].length == 3) {\r\n        for (let c = 0; c < coordinates.length; c++) {\r\n          maxHeight = Math.max(maxHeight, coordinates[c][2]);\r\n        }\r\n      }\r\n\r\n      // Render the cartographic rectangle\r\n      fillGeometry = new Cesium.RectangleGeometry({\r\n        ellipsoid: Cesium.Ellipsoid.WGS84,\r\n        rectangle,\r\n        height: maxHeight\r\n      });\r\n\r\n      outlineGeometry = new Cesium.RectangleOutlineGeometry({\r\n        ellipsoid: Cesium.Ellipsoid.WGS84,\r\n        rectangle,\r\n        height: maxHeight\r\n      });\r\n    } else {\r\n      const rings = olGeometry.getLinearRings();\r\n      // always update Cesium externs before adding a property\r\n      const hierarchy = {};\r\n      const polygonHierarchy = hierarchy;\r\n      console.assert(rings.length > 0);\r\n\r\n      for (let i = 0; i < rings.length; ++i) {\r\n        const olPos = rings[i].getCoordinates();\r\n        const positions = olcsCore.ol4326CoordinateArrayToCsCartesians(olPos);\r\n        console.assert(positions && positions.length > 0);\r\n        if (i == 0) {\r\n          hierarchy.positions = positions;\r\n        } else {\r\n          if (!hierarchy.holes) {\r\n            hierarchy.holes = [];\r\n          }\r\n          hierarchy.holes.push({\r\n            positions\r\n          });\r\n        }\r\n      }\r\n\r\n      fillGeometry = new Cesium.PolygonGeometry({\r\n        // always update Cesium externs before adding a property\r\n        polygonHierarchy,\r\n        perPositionHeight: true\r\n      });\r\n\r\n      // Since Cesium doesn't yet support Polygon outlines on terrain yet (coming soon...?)\r\n      // we don't create an outline geometry if clamped, but instead do the polyline method\r\n      // for each ring. Most of this code should be removeable when Cesium adds\r\n      // support for Polygon outlines on terrain.\r\n      if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\r\n        const width = this.extractLineWidthFromOlStyle(olStyle);\r\n        if (width > 0) {\r\n          const positions = [hierarchy.positions];\r\n          if (hierarchy.holes) {\r\n            for (let i = 0; i < hierarchy.holes.length; ++i) {\r\n              positions.push(hierarchy.holes[i].positions);\r\n            }\r\n          }\r\n          if (!isGroundPolylinePrimitiveSupported(this.scene)) {\r\n            const color = this.extractColorFromOlStyle(olStyle, true);\r\n            outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\r\n          } else {\r\n            const appearance = new Cesium.PolylineMaterialAppearance({\r\n              // always update Cesium externs before adding a property\r\n              material: this.olStyleToCesium(feature, olStyle, true)\r\n            });\r\n            const geometryInstances = [];\r\n            for (const linePositions of positions) {\r\n              const polylineGeometry = new Cesium.GroundPolylineGeometry({positions: linePositions, width});\r\n              geometryInstances.push(new Cesium.GeometryInstance({\r\n                geometry: polylineGeometry\r\n              }));\r\n            }\r\n            const primitiveOptions = {\r\n              // always update Cesium externs before adding a property\r\n              appearance,\r\n              geometryInstances\r\n            };\r\n            outlinePrimitive = new Cesium.GroundPolylinePrimitive(primitiveOptions);\r\n            outlinePrimitive.readyPromise.then(() => {\r\n              this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        // Actually do the normal polygon thing. This should end the removable\r\n        // section of code described above.\r\n        outlineGeometry = new Cesium.PolygonOutlineGeometry({\r\n          // always update Cesium externs before adding a property\r\n          polygonHierarchy: hierarchy,\r\n          perPositionHeight: true\r\n        });\r\n      }\r\n    }\r\n\r\n    const primitives = this.wrapFillAndOutlineGeometries(\r\n        layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);\r\n\r\n    if (outlinePrimitive) {\r\n      primitives.add(outlinePrimitive);\r\n    }\r\n\r\n    return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);\r\n  }\r\n\r\n  /**\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Geometry} geometry\r\n   * @return {!Cesium.HeightReference}\r\n   * @api\r\n   */\r\n  getHeightReference(layer, feature, geometry) {\r\n\r\n    // Read from the geometry\r\n    let altitudeMode = geometry.get('altitudeMode');\r\n\r\n    // Or from the feature\r\n    if (altitudeMode === undefined) {\r\n      altitudeMode = feature.get('altitudeMode');\r\n    }\r\n\r\n    // Or from the layer\r\n    if (altitudeMode === undefined) {\r\n      altitudeMode = layer.get('altitudeMode');\r\n    }\r\n\r\n    let heightReference = Cesium.HeightReference.NONE;\r\n    if (altitudeMode === 'clampToGround') {\r\n      heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;\r\n    } else if (altitudeMode === 'relativeToGround') {\r\n      heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;\r\n    }\r\n\r\n    return heightReference;\r\n  }\r\n\r\n  /**\r\n   * Convert a point geometry to a Cesium BillboardCollection.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} style\r\n   * @param {!ol.style.Image} imageStyle\r\n   * @param {!Cesium.BillboardCollection} billboards\r\n   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when the new billboard is added.\r\n   * @api\r\n   */\r\n  createBillboardFromImage(\r\n      layer,\r\n      feature,\r\n      olGeometry,\r\n      projection,\r\n      style,\r\n      imageStyle,\r\n      billboards,\r\n      opt_newBillboardCallback\r\n  ) {\r\n\r\n    if (imageStyle instanceof olStyleIcon) {\r\n      // make sure the image is scheduled for load\r\n      imageStyle.load();\r\n    }\r\n\r\n    const image = imageStyle.getImage(1); // get normal density\r\n    const isImageLoaded = function(image) {\r\n      return image.src != '' &&\r\n          image.naturalHeight != 0 &&\r\n          image.naturalWidth != 0 &&\r\n          image.complete;\r\n    };\r\n    const reallyCreateBillboard = (function() {\r\n      if (!image) {\r\n        return;\r\n      }\r\n      if (!(image instanceof HTMLCanvasElement ||\r\n          image instanceof Image ||\r\n          image instanceof HTMLImageElement)) {\r\n        return;\r\n      }\r\n      const center = olGeometry.getCoordinates();\r\n      const position = olcsCore.ol4326CoordinateToCesiumCartesian(center);\r\n      let color;\r\n      const opacity = imageStyle.getOpacity();\r\n      if (opacity !== undefined) {\r\n        color = new Cesium.Color(1.0, 1.0, 1.0, opacity);\r\n      }\r\n\r\n      const heightReference = this.getHeightReference(layer, feature, olGeometry);\r\n\r\n      const bbOptions = /** @type {Cesium.optionsBillboardCollectionAdd} */ ({\r\n        // always update Cesium externs before adding a property\r\n        image,\r\n        color,\r\n        scale: imageStyle.getScale(),\r\n        heightReference,\r\n        position\r\n      });\r\n\r\n      if (imageStyle instanceof olStyleIcon) {\r\n        const anchor = imageStyle.getAnchor();\r\n        if (anchor) {\r\n          bbOptions.pixelOffset = new Cesium.Cartesian2(image.width / 2 - anchor[0], image.height / 2 - anchor[1]);\r\n        }\r\n      }\r\n\r\n      const bb = this.csAddBillboard(billboards, bbOptions, layer, feature, olGeometry, style);\r\n      if (opt_newBillboardCallback) {\r\n        opt_newBillboardCallback(bb);\r\n      }\r\n    }).bind(this);\r\n\r\n    if (image instanceof Image && !isImageLoaded(image)) {\r\n      // Cesium requires the image to be loaded\r\n      let cancelled = false;\r\n      const source = layer.getSource();\r\n      const canceller = function() {\r\n        cancelled = true;\r\n      };\r\n      source.on(['removefeature', 'clear'],\r\n          this.boundOnRemoveOrClearFeatureListener_);\r\n      let cancellers = olcsUtil.obj(source)['olcs_cancellers'];\r\n      if (!cancellers) {\r\n        cancellers = olcsUtil.obj(source)['olcs_cancellers'] = {};\r\n      }\r\n\r\n      const fuid = getUid(feature);\r\n      if (cancellers[fuid]) {\r\n        // When the feature change quickly, a canceller may still be present so\r\n        // we cancel it here to prevent creation of a billboard.\r\n        cancellers[fuid]();\r\n      }\r\n      cancellers[fuid] = canceller;\r\n\r\n      const listener = function() {\r\n        image.removeEventListener('load', listener);\r\n        if (!billboards.isDestroyed() && !cancelled) {\r\n          // Create billboard if the feature is still displayed on the map.\r\n          reallyCreateBillboard();\r\n        }\r\n      };\r\n\r\n      image.addEventListener('load', listener);\r\n    } else {\r\n      reallyCreateBillboard();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert a point geometry to a Cesium BillboardCollection.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} style\r\n   * @param {!Cesium.BillboardCollection} billboards\r\n   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when\r\n   * the new billboard is added.\r\n   * @return {Cesium.Primitive} primitives\r\n   * @api\r\n   */\r\n  olPointGeometryToCesium(\r\n      layer,\r\n      feature,\r\n      olGeometry,\r\n      projection,\r\n      style,\r\n      billboards,\r\n      opt_newBillboardCallback\r\n  ) {\r\n    console.assert(olGeometry.getType() == 'Point');\r\n    olGeometry = olcsCore.olGeometryCloneTo4326(olGeometry, projection);\r\n\r\n    let modelPrimitive = null;\r\n    const imageStyle = style.getImage();\r\n    if (imageStyle) {\r\n      const olcsModelFunction = /** @type {function():olcsx.ModelStyle} */ (olGeometry.get('olcs_model') || feature.get('olcs_model'));\r\n      if (olcsModelFunction) {\r\n        const olcsModel = olcsModelFunction();\r\n        const options = /** @type {Cesium.ModelFromGltfOptions} */ (Object.assign({}, {scene: this.scene}, olcsModel.cesiumOptions));\r\n        const model = Cesium.Model.fromGltf(options);\r\n        modelPrimitive = new Cesium.PrimitiveCollection();\r\n        modelPrimitive.add(model);\r\n        if (olcsModel.debugModelMatrix) {\r\n          modelPrimitive.add(new Cesium.DebugModelMatrixPrimitive({\r\n            modelMatrix: olcsModel.debugModelMatrix\r\n          }));\r\n        }\r\n      } else {\r\n        this.createBillboardFromImage(layer, feature, olGeometry, projection, style, imageStyle, billboards, opt_newBillboardCallback);\r\n      }\r\n    }\r\n\r\n    if (style.getText()) {\r\n      return this.addTextStyle(layer, feature, olGeometry, style, modelPrimitive || new Cesium.Primitive());\r\n    } else {\r\n      return modelPrimitive;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers multi-something geometry to Cesium.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Geometry} geometry OpenLayers geometry.\r\n   * @param {!ol.ProjectionLike} projection\r\n   * @param {!ol.style.Style} olStyle\r\n   * @param {!Cesium.BillboardCollection} billboards\r\n   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when\r\n   * the new billboard is added.\r\n   * @return {Cesium.Primitive} primitives\r\n   * @api\r\n   */\r\n  olMultiGeometryToCesium(\r\n      layer,\r\n      feature,\r\n      geometry,\r\n      projection,\r\n      olStyle,\r\n      billboards,\r\n      opt_newBillboardCallback\r\n  ) {\r\n    // Do not reproject to 4326 now because it will be done later.\r\n\r\n    // FIXME: would be better to combine all child geometries in one primitive\r\n    // instead we create n primitives for simplicity.\r\n    const accumulate = function(geometries, functor) {\r\n      const primitives = new Cesium.PrimitiveCollection();\r\n      geometries.forEach((geometry) => {\r\n        primitives.add(functor(layer, feature, geometry, projection, olStyle));\r\n      });\r\n      return primitives;\r\n    };\r\n\r\n    let subgeos;\r\n    switch (geometry.getType()) {\r\n      case 'MultiPoint':\r\n        geometry = /** @type {!ol.geom.MultiPoint} */ (geometry);\r\n        subgeos = geometry.getPoints();\r\n        if (olStyle.getText()) {\r\n          const primitives = new Cesium.PrimitiveCollection();\r\n          subgeos.forEach((geometry) => {\r\n            console.assert(geometry);\r\n            const result = this.olPointGeometryToCesium(layer, feature, geometry,\r\n                projection, olStyle, billboards, opt_newBillboardCallback);\r\n            if (result) {\r\n              primitives.add(result);\r\n            }\r\n          });\r\n          return primitives;\r\n        } else {\r\n          subgeos.forEach((geometry) => {\r\n            console.assert(geometry);\r\n            this.olPointGeometryToCesium(layer, feature, geometry, projection,\r\n                olStyle, billboards, opt_newBillboardCallback);\r\n          });\r\n          return null;\r\n        }\r\n      case 'MultiLineString':\r\n        geometry = /** @type {!ol.geom.MultiLineString} */ (geometry);\r\n        subgeos = geometry.getLineStrings();\r\n        return accumulate(subgeos, this.olLineStringGeometryToCesium.bind(this));\r\n      case 'MultiPolygon':\r\n        geometry = /** @type {!ol.geom.MultiPolygon} */ (geometry);\r\n        subgeos = geometry.getPolygons();\r\n        return accumulate(subgeos, this.olPolygonGeometryToCesium.bind(this));\r\n      default:\r\n        console.assert(false, `Unhandled multi geometry type${geometry.getType()}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers text style to Cesium.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.geom.Geometry} geometry\r\n   * @param {!ol.style.Text} style\r\n   * @return {Cesium.LabelCollection} Cesium primitive\r\n   * @api\r\n   */\r\n  olGeometry4326TextPartToCesium(layer, feature, geometry, style) {\r\n    const text = style.getText();\r\n    if (!text) {\r\n      return null;\r\n    }\r\n\r\n    const labels = new Cesium.LabelCollection({scene: this.scene});\r\n    // TODO: export and use the text draw position from OpenLayers .\r\n    // See src/ol/render/vector.js\r\n    const extentCenter = getCenter(geometry.getExtent());\r\n    if (geometry instanceof olGeomSimpleGeometry) {\r\n      const first = geometry.getFirstCoordinate();\r\n      extentCenter[2] = first.length == 3 ? first[2] : 0.0;\r\n    }\r\n    const options = /** @type {Cesium.optionsLabelCollection} */ ({});\r\n\r\n    options.position = olcsCore.ol4326CoordinateToCesiumCartesian(extentCenter);\r\n\r\n    options.text = text;\r\n\r\n    options.heightReference = this.getHeightReference(layer, feature, geometry);\r\n\r\n    const offsetX = style.getOffsetX();\r\n    const offsetY = style.getOffsetY();\r\n    if (offsetX != 0 && offsetY != 0) {\r\n      const offset = new Cesium.Cartesian2(offsetX, offsetY);\r\n      options.pixelOffset = offset;\r\n    }\r\n\r\n    options.font = style.getFont() || '10px sans-serif'; // OpenLayers default\r\n\r\n    let labelStyle = undefined;\r\n    if (style.getFill()) {\r\n      options.fillColor = this.extractColorFromOlStyle(style, false);\r\n      labelStyle = Cesium.LabelStyle.FILL;\r\n    }\r\n    if (style.getStroke()) {\r\n      options.outlineWidth = this.extractLineWidthFromOlStyle(style);\r\n      options.outlineColor = this.extractColorFromOlStyle(style, true);\r\n      labelStyle = Cesium.LabelStyle.OUTLINE;\r\n    }\r\n    if (style.getFill() && style.getStroke()) {\r\n      labelStyle = Cesium.LabelStyle.FILL_AND_OUTLINE;\r\n    }\r\n    options.style = labelStyle;\r\n\r\n    let horizontalOrigin;\r\n    switch (style.getTextAlign()) {\r\n      case 'left':\r\n        horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\r\n        break;\r\n      case 'right':\r\n        horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\r\n        break;\r\n      case 'center':\r\n      default:\r\n        horizontalOrigin = Cesium.HorizontalOrigin.CENTER;\r\n    }\r\n    options.horizontalOrigin = horizontalOrigin;\r\n\r\n    if (style.getTextBaseline()) {\r\n      let verticalOrigin;\r\n      switch (style.getTextBaseline()) {\r\n        case 'top':\r\n          verticalOrigin = Cesium.VerticalOrigin.TOP;\r\n          break;\r\n        case 'middle':\r\n          verticalOrigin = Cesium.VerticalOrigin.CENTER;\r\n          break;\r\n        case 'bottom':\r\n          verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\r\n          break;\r\n        case 'alphabetic':\r\n          verticalOrigin = Cesium.VerticalOrigin.TOP;\r\n          break;\r\n        case 'hanging':\r\n          verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\r\n          break;\r\n        default:\r\n          console.assert(false, `unhandled baseline ${style.getTextBaseline()}`);\r\n      }\r\n      options.verticalOrigin = verticalOrigin;\r\n    }\r\n\r\n\r\n    const l = labels.add(options);\r\n    this.setReferenceForPicking(layer, feature, l);\r\n    return labels;\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers style to a Cesium Material.\r\n   * @param {ol.Feature} feature OpenLayers feature..\r\n   * @param {!ol.style.Style} style\r\n   * @param {boolean} outline\r\n   * @return {Cesium.Material}\r\n   * @api\r\n   */\r\n  olStyleToCesium(feature, style, outline) {\r\n    const fill = style.getFill();\r\n    const stroke = style.getStroke();\r\n    if ((outline && !stroke) || (!outline && !fill)) {\r\n      return null; // FIXME use a default style? Developer error?\r\n    }\r\n\r\n    let color = outline ? stroke.getColor() : fill.getColor();\r\n    color = olcsCore.convertColorToCesium(color);\r\n\r\n    if (outline && stroke.getLineDash()) {\r\n      return Cesium.Material.fromType('Stripe', {\r\n        // always update Cesium externs before adding a property\r\n        horizontal: false,\r\n        repeat: 500, // TODO how to calculate this?\r\n        evenColor: color,\r\n        oddColor: new Cesium.Color(0, 0, 0, 0) // transparent\r\n      });\r\n    } else {\r\n      return Cesium.Material.fromType('Color', {\r\n        // always update Cesium externs before adding a property\r\n        color\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Compute OpenLayers plain style.\r\n   * Evaluates style function, blend arrays, get default style.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature\r\n   * @param {ol.StyleFunction|undefined} fallbackStyleFunction\r\n   * @param {number} resolution\r\n   * @return {Array.<!ol.style.Style>} null if no style is available\r\n   * @api\r\n   */\r\n  computePlainStyle(layer, feature, fallbackStyleFunction, resolution) {\r\n    /**\r\n     * @type {ol.FeatureStyleFunction|undefined}\r\n     */\r\n    const featureStyleFunction = feature.getStyleFunction();\r\n\r\n    /**\r\n     * @type {ol.style.Style|Array.<ol.style.Style>}\r\n     */\r\n    let style = null;\r\n\r\n    if (featureStyleFunction) {\r\n      style = featureStyleFunction(feature, resolution);\r\n    }\r\n\r\n    if (!style && fallbackStyleFunction) {\r\n      style = fallbackStyleFunction(feature, resolution);\r\n    }\r\n\r\n    if (!style) {\r\n      // The feature must not be displayed\r\n      return null;\r\n    }\r\n\r\n    // FIXME combine materials as in cesium-materials-pack?\r\n    // then this function must return a custom material\r\n    // More simply, could blend the colors like described in\r\n    // http://en.wikipedia.org/wiki/Alpha_compositing\r\n    return Array.isArray(style) ? style : [style];\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {!ol.Feature} feature\r\n   * @param {!ol.style.Style} style\r\n   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.\r\n   * @return {ol.geom.Geometry|undefined}\r\n   */\r\n  getGeometryFromFeature(feature, style, opt_geom) {\r\n    if (opt_geom) {\r\n      return opt_geom;\r\n    }\r\n\r\n    const geom3d = /** @type {!ol.geom.Geometry} */(feature.get('olcs.3d_geometry'));\r\n    if (geom3d && geom3d instanceof olGeomGeometry) {\r\n      return geom3d;\r\n    }\r\n\r\n    if (style) {\r\n      const geomFuncRes = style.getGeometryFunction()(feature);\r\n      if (geomFuncRes instanceof olGeomGeometry) {\r\n        return geomFuncRes;\r\n      }\r\n    }\r\n\r\n    return feature.getGeometry();\r\n  }\r\n\r\n  /**\r\n   * Convert one OpenLayers feature up to a collection of Cesium primitives.\r\n   * @param {ol.layer.Vector|ol.layer.Image} layer\r\n   * @param {!ol.Feature} feature OpenLayers feature.\r\n   * @param {!ol.style.Style} style\r\n   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context\r\n   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.\r\n   * @return {Cesium.Primitive} primitives\r\n   * @api\r\n   */\r\n  olFeatureToCesium(layer, feature, style, context, opt_geom) {\r\n    let geom = this.getGeometryFromFeature(feature, style, opt_geom);\r\n\r\n    if (!geom) {\r\n      // OpenLayers features may not have a geometry\r\n      // See http://geojson.org/geojson-spec.html#feature-objects\r\n      return null;\r\n    }\r\n\r\n    const proj = context.projection;\r\n    const newBillboardAddedCallback = function(bb) {\r\n      const featureBb = context.featureToCesiumMap[getUid(feature)];\r\n      if (featureBb instanceof Array) {\r\n        featureBb.push(bb);\r\n      }\r\n      else {\r\n        context.featureToCesiumMap[getUid(feature)] = [bb];\r\n      }\r\n    };\r\n\r\n    switch (geom.getType()) {\r\n      case 'GeometryCollection':\r\n        const primitives = new Cesium.PrimitiveCollection();\r\n        const collection = /** @type {!ol.geom.GeometryCollection} */ (geom);\r\n        // TODO: use getGeometriesArray() instead\r\n        collection.getGeometries().forEach((geom) => {\r\n          if (geom) {\r\n            const prims = this.olFeatureToCesium(layer, feature, style, context,\r\n                geom);\r\n            if (prims) {\r\n              primitives.add(prims);\r\n            }\r\n          }\r\n        });\r\n        return primitives;\r\n      case 'Point':\r\n        geom = /** @type {!ol.geom.Point} */ (geom);\r\n        const bbs = context.billboards;\r\n        const result = this.olPointGeometryToCesium(layer, feature, geom, proj,\r\n            style, bbs, newBillboardAddedCallback);\r\n        if (!result) {\r\n          // no wrapping primitive\r\n          return null;\r\n        } else {\r\n          return result;\r\n        }\r\n      case 'Circle':\r\n        geom = /** @type {!ol.geom.Circle} */ (geom);\r\n        return this.olCircleGeometryToCesium(layer, feature, geom, proj,\r\n            style);\r\n      case 'LineString':\r\n        geom = /** @type {!ol.geom.LineString} */ (geom);\r\n        return this.olLineStringGeometryToCesium(layer, feature, geom, proj,\r\n            style);\r\n      case 'Polygon':\r\n        geom = /** @type {!ol.geom.Polygon} */ (geom);\r\n        return this.olPolygonGeometryToCesium(layer, feature, geom, proj,\r\n            style);\r\n      case 'MultiPoint':\r\n      case 'MultiLineString':\r\n      case 'MultiPolygon':\r\n        const result2 = this.olMultiGeometryToCesium(layer, feature, geom, proj,\r\n            style, context.billboards, newBillboardAddedCallback);\r\n        if (!result2) {\r\n          // no wrapping primitive\r\n          return null;\r\n        } else {\r\n          return result2;\r\n        }\r\n      case 'LinearRing':\r\n        throw new Error('LinearRing should only be part of polygon.');\r\n      default:\r\n        throw new Error(`Ol geom type not handled : ${geom.getType()}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers vector layer to Cesium primitive collection.\r\n   * For each feature, the associated primitive will be stored in\r\n   * `featurePrimitiveMap`.\r\n   * @param {!(ol.layer.Vector|ol.layer.Image)} olLayer\r\n   * @param {!ol.View} olView\r\n   * @param {!Object.<number, !Cesium.Primitive>} featurePrimitiveMap\r\n   * @return {!olcs.core.VectorLayerCounterpart}\r\n   * @api\r\n   */\r\n  olVectorLayerToCesium(olLayer, olView, featurePrimitiveMap) {\r\n    const proj = olView.getProjection();\r\n    const resolution = olView.getResolution();\r\n\r\n    if (resolution === undefined || !proj) {\r\n      console.assert(false, 'View not ready');\r\n      // an assertion is not enough for closure to assume resolution and proj\r\n      // are defined\r\n      throw new Error('View not ready');\r\n    }\r\n\r\n    let source = olLayer.getSource();\r\n    if (source instanceof olSourceCluster) {\r\n      source = source.getSource();\r\n    }\r\n\r\n    console.assert(source instanceof olSourceVector);\r\n    const features = source.getFeatures();\r\n    const counterpart = new olcsCoreVectorLayerCounterpart(proj, this.scene);\r\n    const context = counterpart.context;\r\n    for (let i = 0; i < features.length; ++i) {\r\n      const feature = features[i];\r\n      if (!feature) {\r\n        continue;\r\n      }\r\n      /**\r\n       * @type {ol.StyleFunction|undefined}\r\n       */\r\n      const layerStyle = olLayer.getStyleFunction();\r\n      const styles = this.computePlainStyle(olLayer, feature, layerStyle,\r\n          resolution);\r\n      if (!styles || !styles.length) {\r\n        // only 'render' features with a style\r\n        continue;\r\n      }\r\n\r\n      /**\r\n       * @type {Cesium.Primitive|null}\r\n       */\r\n      let primitives = null;\r\n      for (let i = 0; i < styles.length; i++) {\r\n        const prims = this.olFeatureToCesium(olLayer, feature, styles[i], context);\r\n        if (prims) {\r\n          if (!primitives) {\r\n            primitives = prims;\r\n          } else if (prims) {\r\n            let i = 0, prim;\r\n            while ((prim = prims.get(i))) {\r\n              primitives.add(prim);\r\n              i++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!primitives) {\r\n        continue;\r\n      }\r\n      featurePrimitiveMap[getUid(feature)] = primitives;\r\n      counterpart.getRootPrimitive().add(primitives);\r\n    }\r\n\r\n    return counterpart;\r\n  }\r\n\r\n  /**\r\n   * Convert an OpenLayers feature to Cesium primitive collection.\r\n   * @param {!(ol.layer.Vector|ol.layer.Image)} layer\r\n   * @param {!ol.View} view\r\n   * @param {!ol.Feature} feature\r\n   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context\r\n   * @return {Cesium.Primitive}\r\n   * @api\r\n   */\r\n  convert(layer, view, feature, context) {\r\n    const proj = view.getProjection();\r\n    const resolution = view.getResolution();\r\n\r\n    if (resolution == undefined || !proj) {\r\n      return null;\r\n    }\r\n\r\n    /**\r\n     * @type {ol.StyleFunction|undefined}\r\n     */\r\n    const layerStyle = layer.getStyleFunction();\r\n\r\n    const styles = this.computePlainStyle(layer, feature, layerStyle, resolution);\r\n\r\n    if (!styles || !styles.length) {\r\n      // only 'render' features with a style\r\n      return null;\r\n    }\r\n\r\n    context.projection = proj;\r\n\r\n    /**\r\n     * @type {Cesium.Primitive|null}\r\n     */\r\n    let primitives = null;\r\n    for (let i = 0; i < styles.length; i++) {\r\n      const prims = this.olFeatureToCesium(layer, feature, styles[i], context);\r\n      if (!primitives) {\r\n        primitives = prims;\r\n      } else if (prims) {\r\n        let i = 0, prim;\r\n        while ((prim = prims.get(i))) {\r\n          primitives.add(prim);\r\n          i++;\r\n        }\r\n      }\r\n    }\r\n    return primitives;\r\n  }\r\n}\r\n\r\n\r\nexport default FeatureConverter;\r\n","/**\r\n * @module olcs.VectorSynchronizer\r\n */\r\nimport olSourceVector from 'ol/source/Vector.js';\r\nimport olLayerLayer from 'ol/layer/Layer.js';\r\nimport olSourceCluster from 'ol/source/Cluster.js';\r\nimport olLayerImage from 'ol/layer/Image.js';\r\nimport {olcsListen, getUid} from './util.js';\r\nimport olLayerVector from 'ol/layer/Vector.js';\r\nimport olLayerVectorTile from 'ol/layer/VectorTile.js';\r\nimport olcsAbstractSynchronizer from './AbstractSynchronizer.js';\r\nimport olcsFeatureConverter from './FeatureConverter.js';\r\n\r\nclass VectorSynchronizer extends olcsAbstractSynchronizer {\r\n  /**\r\n   * Unidirectionally synchronize OpenLayers vector layers to Cesium.\r\n   * @param {!ol.Map} map\r\n   * @param {!Cesium.Scene} scene\r\n   * @param {olcs.FeatureConverter=} opt_converter\r\n   * @extends {olcs.AbstractSynchronizer.<olcs.core.VectorLayerCounterpart>}\r\n   * @api\r\n   */\r\n  constructor(map, scene, opt_converter) {\r\n    super(map, scene);\r\n\r\n    /**\r\n     * @protected\r\n     */\r\n    this.converter = opt_converter || new olcsFeatureConverter(scene);\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.csAllPrimitives_ = new Cesium.PrimitiveCollection();\r\n    scene.primitives.add(this.csAllPrimitives_);\r\n    this.csAllPrimitives_.destroyPrimitives = false;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  addCesiumObject(counterpart) {\r\n    console.assert(counterpart);\r\n    counterpart.getRootPrimitive()['counterpart'] = counterpart;\r\n    this.csAllPrimitives_.add(counterpart.getRootPrimitive());\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  destroyCesiumObject(object) {\r\n    object.getRootPrimitive().destroy();\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  removeSingleCesiumObject(object, destroy) {\r\n    object.destroy();\r\n    this.csAllPrimitives_.destroyPrimitives = destroy;\r\n    this.csAllPrimitives_.remove(object.getRootPrimitive());\r\n    this.csAllPrimitives_.destroyPrimitives = false;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  removeAllCesiumObjects(destroy) {\r\n    this.csAllPrimitives_.destroyPrimitives = destroy;\r\n    if (destroy) {\r\n      for (let i = 0; i < this.csAllPrimitives_.length; ++i) {\r\n        this.csAllPrimitives_.get(i)['counterpart'].destroy();\r\n      }\r\n    }\r\n    this.csAllPrimitives_.removeAll();\r\n    this.csAllPrimitives_.destroyPrimitives = false;\r\n  }\r\n\r\n  /**\r\n   * Synchronizes the layer visibility properties\r\n   * to the given Cesium Primitive.\r\n   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents\r\n   * @param {!Cesium.Primitive} csPrimitive\r\n   */\r\n  updateLayerVisibility(olLayerWithParents, csPrimitive) {\r\n    let visible = true;\r\n    [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayer) => {\r\n      const layerVisible = olLayer.getVisible();\r\n      if (layerVisible !== undefined) {\r\n        visible &= layerVisible;\r\n      } else {\r\n        visible = false;\r\n      }\r\n    });\r\n    csPrimitive.show = visible;\r\n  }\r\n\r\n  /**\r\n   * @inheritDoc\r\n   */\r\n  createSingleLayerCounterparts(olLayerWithParents) {\r\n    const olLayer = olLayerWithParents.layer;\r\n    if (!(olLayer instanceof olLayerVector) || olLayer instanceof olLayerVectorTile) {\r\n      return null;\r\n    }\r\n    console.assert(olLayer instanceof olLayerLayer);\r\n\r\n    let source = olLayer.getSource();\r\n    if (source instanceof olSourceCluster) {\r\n      source = source.getSource();\r\n    }\r\n\r\n    if (!source) {\r\n      return null;\r\n    }\r\n\r\n    console.assert(source instanceof olSourceVector);\r\n    console.assert(this.view);\r\n\r\n    const view = this.view;\r\n    const featurePrimitiveMap = {};\r\n    const counterpart = this.converter.olVectorLayerToCesium(olLayer, view,\r\n        featurePrimitiveMap);\r\n    const csPrimitives = counterpart.getRootPrimitive();\r\n    const olListenKeys = counterpart.olListenKeys;\r\n\r\n    [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayerItem) => {\r\n      olListenKeys.push(olcsListen(olLayerItem, 'change:visible', () => {\r\n        this.updateLayerVisibility(olLayerWithParents, csPrimitives);\r\n      }));\r\n    });\r\n    this.updateLayerVisibility(olLayerWithParents, csPrimitives);\r\n\r\n    const onAddFeature = (function(feature) {\r\n      console.assert(\r\n          (olLayer instanceof olLayerVector) ||\r\n          (olLayer instanceof olLayerImage)\r\n      );\r\n      const context = counterpart.context;\r\n      const prim = this.converter.convert(olLayer, view, feature, context);\r\n      if (prim) {\r\n        featurePrimitiveMap[getUid(feature)] = prim;\r\n        csPrimitives.add(prim);\r\n      }\r\n    }).bind(this);\r\n\r\n    const onRemoveFeature = (function(feature) {\r\n      const id = getUid(feature);\r\n      const context = counterpart.context;\r\n      const bbs = context.featureToCesiumMap[id];\r\n      if (bbs) {\r\n        delete context.featureToCesiumMap[id];\r\n        bbs.forEach((bb) => {\r\n          if (bb instanceof Cesium.Billboard) {\r\n            context.billboards.remove(bb);\r\n          }\r\n        });\r\n      }\r\n      const csPrimitive = featurePrimitiveMap[id];\r\n      delete featurePrimitiveMap[id];\r\n      if (csPrimitive) {\r\n        csPrimitives.remove(csPrimitive);\r\n      }\r\n    }).bind(this);\r\n\r\n    olListenKeys.push(olcsListen(source, 'addfeature', (e) => {\r\n      console.assert(e.feature);\r\n      onAddFeature(e.feature);\r\n    }, this));\r\n\r\n    olListenKeys.push(olcsListen(source, 'removefeature', (e) => {\r\n      console.assert(e.feature);\r\n      onRemoveFeature(e.feature);\r\n    }, this));\r\n\r\n    olListenKeys.push(olcsListen(source, 'changefeature', (e) => {\r\n      const feature = e.feature;\r\n      console.assert(feature);\r\n      onRemoveFeature(feature);\r\n      onAddFeature(feature);\r\n    }, this));\r\n\r\n    return counterpart ? [counterpart] : null;\r\n  }\r\n}\r\n\r\nexport default VectorSynchronizer;\r\n","/**\r\n * @module olcs.SynchronizedOverlay\r\n */\r\nimport olOverlay from 'ol/Overlay.js';\r\nimport {transform} from 'ol/proj.js';\r\nimport {removeNode, removeChildren} from './util.js';\r\nimport {unByKey as olObservableUnByKey} from 'ol/Observable.js';\r\n\r\n\r\n/**\r\n * Options for SynchronizedOverlay\r\n * @typedef {Object} SynchronizedOverlayOptions\r\n * @property {!Cesium.Scene} scene\r\n * @property {olOverlay} parent\r\n * @property {!import('olsc/OverlaySynchronizer.js').default} synchronizer\r\n */\r\n\r\n\r\nclass SynchronizedOverlay extends olOverlay {\r\n  /**\r\n   * @param {olcsx.SynchronizedOverlayOptions} options SynchronizedOverlay Options.\r\n   * @api\r\n   */\r\n  constructor(options) {\r\n    const parent = options.parent;\r\n    super(parent.getOptions());\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Function}\r\n     */\r\n    this.scenePostRenderListenerRemover_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Cesium.Scene}\r\n     */\r\n    this.scene_ = options.scene;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!olcs.OverlaySynchronizer}\r\n     */\r\n    this.synchronizer_ = options.synchronizer;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!ol.Overlay}\r\n     */\r\n    this.parent_ = parent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {ol.Coordinate|undefined}\r\n     */\r\n    this.positionWGS84_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {MutationObserver}\r\n     */\r\n    this.observer_ = new MutationObserver(this.handleElementChanged.bind(this));\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array.<MutationObserver>}\r\n     */\r\n    this.attributeObserver_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<ol.EventsKey>}\r\n     */\r\n    this.listenerKeys_ = [];\r\n    // synchronize our Overlay with the parent Overlay\r\n    const setPropertyFromEvent = event => this.setPropertyFromEvent_(event);\r\n    this.listenerKeys_.push(this.parent_.on('change:position', setPropertyFromEvent));\r\n    this.listenerKeys_.push(this.parent_.on('change:element', setPropertyFromEvent));\r\n    this.listenerKeys_.push(this.parent_.on('change:offset', setPropertyFromEvent));\r\n    this.listenerKeys_.push(this.parent_.on('change:position', setPropertyFromEvent));\r\n    this.listenerKeys_.push(this.parent_.on('change:positioning', setPropertyFromEvent));\r\n\r\n    this.setProperties(this.parent_.getProperties());\r\n\r\n    this.handleMapChanged();\r\n    this.handleElementChanged();\r\n  }\r\n\r\n  /**\r\n   * @param {Node} target\r\n   * @private\r\n   */\r\n  observeTarget_(target) {\r\n    if (!this.observer_) {\r\n      // not ready, skip the event (this occurs on construction)\r\n      return;\r\n    }\r\n    this.observer_.disconnect();\r\n    this.observer_.observe(target, {\r\n      attributes: false,\r\n      childList: true,\r\n      characterData: true,\r\n      subtree: true\r\n    });\r\n    this.attributeObserver_.forEach((observer) => {\r\n      observer.disconnect();\r\n    });\r\n    this.attributeObserver_.length = 0;\r\n    for (let i = 0; i < target.childNodes.length; i++) {\r\n      const node = target.childNodes[i];\r\n      if (node.nodeType === 1) {\r\n        const observer = new MutationObserver(this.handleElementChanged.bind(this));\r\n        observer.observe(node, {\r\n          attributes: true,\r\n          subtree: true\r\n        });\r\n        this.attributeObserver_.push(observer);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {ol.Object.Event} event\r\n   * @private\r\n   */\r\n  setPropertyFromEvent_(event) {\r\n    if (event.target && event.key) {\r\n      this.set(event.key, event.target.get(event.key));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the scene associated with this overlay.\r\n   * @see ol.Overlay.prototype.getMap\r\n   * @return {!Cesium.Scene} The scene that the overlay is part of.\r\n   * @api\r\n   */\r\n  getScene() {\r\n    return this.scene_;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  handleMapChanged() {\r\n    if (this.scenePostRenderListenerRemover_) {\r\n      this.scenePostRenderListenerRemover_();\r\n      removeNode(this.element);\r\n    }\r\n    this.scenePostRenderListenerRemover_ = null;\r\n    const scene = this.getScene();\r\n    if (scene) {\r\n      this.scenePostRenderListenerRemover_ = scene.postRender.addEventListener(this.updatePixelPosition.bind(this));\r\n      this.updatePixelPosition();\r\n      const container = this.stopEvent ?\r\n        this.synchronizer_.getOverlayContainerStopEvent() : this.synchronizer_.getOverlayContainer();\r\n      if (this.insertFirst) {\r\n        container.insertBefore(this.element, container.childNodes[0] || null);\r\n      } else {\r\n        container.appendChild(this.element);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  handlePositionChanged() {\r\n    // transform position to WGS84\r\n    const position = this.getPosition();\r\n    if (position) {\r\n      const sourceProjection = this.parent_.getMap().getView().getProjection();\r\n      this.positionWGS84_ = transform(position, sourceProjection, 'EPSG:4326');\r\n    } else {\r\n      this.positionWGS84_ = undefined;\r\n    }\r\n    this.updatePixelPosition();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  handleElementChanged() {\r\n    function cloneNode(node, parent) {\r\n      const clone = node.cloneNode();\r\n      if (parent) {\r\n        parent.appendChild(clone);\r\n      }\r\n      if (node.nodeType != Node.TEXT_NODE) {\r\n        clone.addEventListener('click', (event) => {\r\n          node.dispatchEvent(new MouseEvent('click', event));\r\n          event.stopPropagation();\r\n        });\r\n      }\r\n      const nodes = node.childNodes;\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        if (!nodes[i]) {\r\n          continue;\r\n        }\r\n        cloneNode(nodes[i], clone);\r\n      }\r\n      return clone;\r\n    }\r\n    removeChildren(this.element);\r\n    const element = this.getElement();\r\n    if (element) {\r\n      if (element.parentNode && element.parentNode.childNodes) {\r\n        for (const node of element.parentNode.childNodes) {\r\n          const clonedNode = cloneNode(node, null);\r\n          this.element.appendChild(clonedNode);\r\n        }\r\n      }\r\n    }\r\n    if (element && element.parentNode) {\r\n      // set new Observer\r\n      this.observeTarget_(element.parentNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  updatePixelPosition() {\r\n    const position = this.positionWGS84_;\r\n    if (!this.scene_ || !position) {\r\n      this.setVisible(false);\r\n      return;\r\n    }\r\n    let height = 0;\r\n    if (position.length === 2) {\r\n      const globeHeight = this.scene_.globe.getHeight(Cesium.Cartographic.fromDegrees(position[0], position[1]));\r\n      if (globeHeight && this.scene_.globe.tilesLoaded) {\r\n        position[2] = globeHeight;\r\n      }\r\n      if (globeHeight) {\r\n        height = globeHeight;\r\n      }\r\n    } else {\r\n      height = position[2];\r\n    }\r\n    const cartesian = Cesium.Cartesian3.fromDegrees(position[0], position[1], height);\r\n    const camera = this.scene_.camera;\r\n    const ellipsoidBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(), 6356752);\r\n    const occluder = new Cesium.Occluder(ellipsoidBoundingSphere, camera.position);\r\n    // check if overlay position is behind the horizon\r\n    if (!occluder.isPointVisible(cartesian)) {\r\n      this.setVisible(false);\r\n      return;\r\n    }\r\n    const cullingVolume = camera.frustum.computeCullingVolume(camera.position, camera.direction, camera.up);\r\n    // check if overlay position is visible from the camera\r\n    if (cullingVolume.computeVisibility(new Cesium.BoundingSphere(cartesian)) !== 1) {\r\n      this.setVisible(false);\r\n      return;\r\n    }\r\n    this.setVisible(true);\r\n\r\n    const pixelCartesian = this.scene_.cartesianToCanvasCoordinates(cartesian);\r\n    const pixel = [pixelCartesian.x, pixelCartesian.y];\r\n    const mapSize = [this.scene_.canvas.width, this.scene_.canvas.height];\r\n    this.updateRenderedPosition(pixel, mapSize);\r\n  }\r\n\r\n  /**\r\n   * Destroys the overlay, removing all its listeners and elements\r\n   * @api\r\n   */\r\n  destroy() {\r\n    if (this.scenePostRenderListenerRemover_) {\r\n      this.scenePostRenderListenerRemover_();\r\n    }\r\n    if (this.observer_) {\r\n      this.observer_.disconnect();\r\n    }\r\n    olObservableUnByKey(this.listenerKeys_);\r\n    this.listenerKeys_.splice(0);\r\n    if (this.element.removeNode) {\r\n      this.element.removeNode(true);\r\n    } else {\r\n      this.element.remove();\r\n    }\r\n    this.element = null;\r\n  }\r\n}\r\n\r\nexport default SynchronizedOverlay;\r\n","/**\r\n * @module olcs.OverlaySynchronizer\r\n */\r\nimport olcsSynchronizedOverlay from './SynchronizedOverlay.js';\r\nimport {getUid} from './util.js';\r\n\r\nclass OverlaySynchronizer {\r\n  /**\r\n  * @param {!ol.Map} map\r\n  * @param {!Cesium.Scene} scene\r\n  * @constructor\r\n  * @template T\r\n  * @api\r\n  */\r\n  constructor(map, scene) {\r\n    /**\r\n    * @type {!ol.Map}\r\n    * @protected\r\n    */\r\n    this.map = map;\r\n\r\n    /**\r\n    * @type {ol.Collection.<ol.Overlay>}\r\n    * @private\r\n    */\r\n    this.overlays_ = this.map.getOverlays();\r\n\r\n    /**\r\n    * @type {!Cesium.Scene}\r\n    * @protected\r\n    */\r\n    this.scene = scene;\r\n\r\n    /**\r\n    * @private\r\n    * @type {!Element}\r\n    */\r\n    this.overlayContainerStopEvent_ = document.createElement('DIV');\r\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\r\n    const overlayEvents = ['click', 'dblclick', 'mousedown', 'touchstart', 'MSPointerDown', 'pointerdown', 'mousewheel', 'wheel'];\r\n    overlayEvents.forEach((event) => {\r\n      this.overlayContainerStopEvent_.addEventListener(event, evt => evt.stopPropagation());\r\n    });\r\n    this.scene.canvas.parentElement.appendChild(this.overlayContainerStopEvent_);\r\n\r\n    /**\r\n    * @private\r\n    * @type {!Element}\r\n    */\r\n    this.overlayContainer_ = document.createElement('DIV');\r\n    this.overlayContainer_.className = 'ol-overlaycontainer';\r\n    this.scene.canvas.parentElement.appendChild(this.overlayContainer_);\r\n\r\n\r\n    /**\r\n    * @type {!Object<?,olcs.SynchronizedOverlay>}\r\n    * @private\r\n    */\r\n    this.overlayMap_ = {};\r\n  }\r\n\r\n  /**\r\n  * Get the element that serves as a container for overlays that don't allow\r\n  * event propagation. Elements added to this container won't let mousedown and\r\n  * touchstart events through to the map, so clicks and gestures on an overlay\r\n  * don't trigger any {@link ol.MapBrowserEvent}.\r\n  * @return {!Element} The map's overlay container that stops events.\r\n  */\r\n  getOverlayContainerStopEvent() {\r\n    return this.overlayContainerStopEvent_;\r\n  }\r\n\r\n  /**\r\n  * Get the element that serves as a container for overlays.\r\n  * @return {!Element} The map's overlay container.\r\n  */\r\n  getOverlayContainer() {\r\n    return this.overlayContainer_;\r\n  }\r\n\r\n  /**\r\n  * Destroy all and perform complete synchronization of the overlays.\r\n  * @api\r\n  */\r\n  synchronize() {\r\n    this.destroyAll();\r\n    this.addOverlays();\r\n    this.overlays_.on('add', this.addOverlayFromEvent_.bind(this));\r\n    this.overlays_.on('remove', this.removeOverlayFromEvent_.bind(this));\r\n  }\r\n\r\n  /**\r\n  * @param {ol.Collection.Event} event\r\n  * @private\r\n  */\r\n  addOverlayFromEvent_(event) {\r\n    const overlay = /** @type {ol.Overlay} */ (event.element);\r\n    this.addOverlay(overlay);\r\n  }\r\n\r\n  /**\r\n  * @api\r\n  */\r\n  addOverlays() {\r\n    this.overlays_.forEach((overlay) => { this.addOverlay(overlay); });\r\n  }\r\n\r\n  /**\r\n  * @param {ol.Overlay} overlay\r\n  * @api\r\n  */\r\n  addOverlay(overlay) {\r\n    if (!overlay) {\r\n      return;\r\n    }\r\n    const cesiumOverlay = new olcsSynchronizedOverlay({\r\n      scene: this.scene,\r\n      synchronizer: this,\r\n      parent: overlay\r\n    });\r\n\r\n    const overlayId = getUid(overlay).toString();\r\n    this.overlayMap_[overlayId] = cesiumOverlay;\r\n  }\r\n\r\n  /**\r\n  * @param {ol.Collection.Event} event\r\n  * @private\r\n  */\r\n  removeOverlayFromEvent_(event) {\r\n    const removedOverlay = /** @type {ol.Overlay} */ (event.element);\r\n    this.removeOverlay(removedOverlay);\r\n  }\r\n\r\n  /**\r\n  * Removes an overlay from the scene\r\n  * @param {ol.Overlay} overlay\r\n  * @api\r\n  */\r\n  removeOverlay(overlay) {\r\n    const overlayId = getUid(overlay).toString();\r\n    const csOverlay = this.overlayMap_[overlayId];\r\n    if (csOverlay) {\r\n      csOverlay.destroy();\r\n      delete this.overlayMap_[overlayId];\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Destroys all the created Cesium objects.\r\n  * @protected\r\n  */\r\n  destroyAll() {\r\n    Object.keys(this.overlayMap_).forEach((key) => {\r\n      const overlay = this.overlayMap_[key];\r\n      overlay.destroy();\r\n      delete this.overlayMap_[key];\r\n    });\r\n  }\r\n}\r\n\r\n\r\nexport default OverlaySynchronizer;\r\n","/**\r\n * @module olcs.OLCesium\r\n */\r\nimport olGeomPoint from 'ol/geom/Point.js';\r\nimport {getTransform} from 'ol/proj.js';\r\nimport olcsUtil from './util.js';\r\nimport olcsCore from './core.js';\r\nimport olcsAutoRenderLoop from './AutoRenderLoop.js';\r\nimport olcsCamera from './Camera.js';\r\nimport olcsRasterSynchronizer from './RasterSynchronizer.js';\r\nimport olcsVectorSynchronizer from './VectorSynchronizer.js';\r\nimport olcsOverlaySynchronizer from './OverlaySynchronizer.js';\r\n\r\n\r\n/**\r\n * @typedef {Object} OLCesiumOptions\r\n * @property {import('ol/Map.js').default} map The OpenLayers map we want to show on a Cesium scene.\r\n * @property {Element|string} [target] Target element for the Cesium scene.\r\n * @property {function(!import('ol/Map.js').default, !Cesium.Scene, !Cesium.DataSourceCollection): Array<import('olcs/AbstractSynchronizer.js').default>}\r\n *      [createSynchronizers] Callback function which will be called by the {@link olcs.OLCesium}\r\n *      constructor to create custom synchronizers. Receives an `ol.Map` and a `Cesium.Scene` as arguments,\r\n *      and needs to return an array of {@link import('olcs/AbstractSynchronizer.js').default}.\r\n * @property {function(): Cesium.JulianDate} [time] Control the current time used by Cesium.\r\n * @property {boolean} [stopOpenLayersEventsPropagation] Prevent propagation of mouse/touch events to\r\n *      OpenLayers when Cesium is active.\r\n * @property {Cesium.SceneOptions} [sceneOptions] Allows the passing of property value to the\r\n *      `Cesium.Scene`.\r\n */\r\n\r\n\r\nclass OLCesium {\r\n  /**\r\n   * @param {!OLCesiumOptions} options Options.\r\n   * @constructor\r\n   * @api\r\n   */\r\n  constructor(options) {\r\n\r\n    /**\r\n     * @type {olcs.AutoRenderLoop}\r\n     * @private\r\n     */\r\n    this.autoRenderLoop_ = null;\r\n\r\n    /**\r\n     * @type {!ol.Map}\r\n     * @private\r\n     */\r\n    this.map_ = options.map;\r\n\r\n    /**\r\n     * @type {!function(): Cesium.JulianDate}\r\n     * @private\r\n     */\r\n    this.time_ = options.time || function() {\r\n      return Cesium.JulianDate.now();\r\n    };\r\n\r\n    /**\r\n     * No change of the view projection.\r\n     * @private\r\n     */\r\n    this.to4326Transform_ = getTransform(this.map_.getView().getProjection(), 'EPSG:4326');\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.resolutionScale_ = 1.0;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.canvasClientWidth_ = 0.0;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.canvasClientHeight_ = 0.0;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.resolutionScaleChanged_ = true; // force resize\r\n\r\n    const fillArea = 'position:absolute;top:0;left:0;width:100%;height:100%;';\r\n\r\n    /**\r\n     * @type {!Element}\r\n     * @private\r\n     */\r\n    this.container_ = document.createElement('DIV');\r\n    const containerAttribute = document.createAttribute('style');\r\n    containerAttribute.value = `${fillArea}visibility:hidden;`;\r\n    this.container_.setAttributeNode(containerAttribute);\r\n\r\n    let targetElement = options.target || null;\r\n    if (targetElement) {\r\n      if (typeof targetElement === 'string') {\r\n        targetElement = document.getElementById(targetElement);\r\n      }\r\n      targetElement.appendChild(this.container_);\r\n    } else {\r\n      const oc = this.map_.getViewport().querySelector('.ol-overlaycontainer');\r\n      if (oc && oc.parentNode) {\r\n        oc.parentNode.insertBefore(this.container_, oc);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Whether the Cesium container is placed over the ol map.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.isOverMap_ = !targetElement;\r\n\r\n\r\n    if (this.isOverMap_ && options.stopOpenLayersEventsPropagation) {\r\n      const overlayEvents = ['click', 'dblclick', 'mousedown', 'touchstart', 'MSPointerDown', 'pointerdown', 'mousewheel', 'wheel'];\r\n      for (let i = 0, ii = overlayEvents.length; i < ii; ++i) {\r\n        this.container_.addEventListener(overlayEvents[i], evt => evt.stopPropagation());\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @type {!HTMLCanvasElement}\r\n     * @private\r\n     */\r\n    this.canvas_ = /** @type {!HTMLCanvasElement} */ (document.createElement('CANVAS'));\r\n    const canvasAttribute = document.createAttribute('style');\r\n    canvasAttribute.value = fillArea;\r\n    this.canvas_.setAttributeNode(canvasAttribute);\r\n\r\n    if (olcsUtil.supportsImageRenderingPixelated()) {\r\n      // non standard CSS4\r\n      this.canvas_.style['imageRendering'] = olcsUtil.imageRenderingValue();\r\n    }\r\n\r\n    this.canvas_.oncontextmenu = function() { return false; };\r\n    this.canvas_.onselectstart = function() { return false; };\r\n\r\n    this.container_.appendChild(this.canvas_);\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.enabled_ = false;\r\n\r\n    /**\r\n     * @type {!Array.<ol.interaction.Interaction>}\r\n     * @private\r\n     */\r\n    this.pausedInteractions_ = [];\r\n\r\n    /**\r\n     * @type {?ol.layer.Group}\r\n     * @private\r\n     */\r\n    this.hiddenRootGroup_ = null;\r\n\r\n    const sceneOptions = options.sceneOptions !== undefined ? options.sceneOptions :\r\n      /** @type {Cesium.SceneOptions} */ ({});\r\n    sceneOptions.canvas = this.canvas_;\r\n    sceneOptions.scene3DOnly = true;\r\n\r\n    /**\r\n     * @type {!Cesium.Scene}\r\n     * @private\r\n     */\r\n    this.scene_ = new Cesium.Scene(sceneOptions);\r\n\r\n    const sscc = this.scene_.screenSpaceCameraController;\r\n\r\n    sscc.tiltEventTypes.push({\r\n      'eventType': Cesium.CameraEventType.LEFT_DRAG,\r\n      'modifier': Cesium.KeyboardEventModifier.SHIFT\r\n    });\r\n\r\n    sscc.tiltEventTypes.push({\r\n      'eventType': Cesium.CameraEventType.LEFT_DRAG,\r\n      'modifier': Cesium.KeyboardEventModifier.ALT\r\n    });\r\n\r\n    sscc.enableLook = false;\r\n\r\n    this.scene_.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z;\r\n\r\n    /**\r\n     * @type {!olcs.Camera}\r\n     * @private\r\n     */\r\n    this.camera_ = new olcsCamera(this.scene_, this.map_);\r\n\r\n    /**\r\n     * @type {!Cesium.Globe}\r\n     * @private\r\n     */\r\n    this.globe_ = new Cesium.Globe(Cesium.Ellipsoid.WGS84);\r\n    this.globe_.baseColor = Cesium.Color.WHITE;\r\n    this.scene_.globe = this.globe_;\r\n    this.scene_.skyAtmosphere = new Cesium.SkyAtmosphere();\r\n\r\n    // The first layer of Cesium is special; using a 1x1 transparent image to workaround it.\r\n    // See https://github.com/AnalyticalGraphicsInc/cesium/issues/1323 for details.\r\n    const firstImageryProvider = new Cesium.SingleTileImageryProvider({\r\n      url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\r\n      rectangle: Cesium.Rectangle.fromDegrees(0, 0, 1, 1) // the Rectangle dimensions are arbitrary\r\n    });\r\n    this.globe_.imageryLayers.addImageryProvider(firstImageryProvider, 0);\r\n\r\n    this.dataSourceCollection_ = new Cesium.DataSourceCollection();\r\n    this.dataSourceDisplay_ = new Cesium.DataSourceDisplay({\r\n      scene: this.scene_,\r\n      dataSourceCollection: this.dataSourceCollection_\r\n    });\r\n\r\n    const synchronizers = options.createSynchronizers ?\r\n      options.createSynchronizers(this.map_, this.scene_, this.dataSourceCollection_) : [\r\n        new olcsRasterSynchronizer(this.map_, this.scene_),\r\n        new olcsVectorSynchronizer(this.map_, this.scene_),\r\n        new olcsOverlaySynchronizer(this.map_, this.scene_)\r\n      ];\r\n\r\n    // Assures correct canvas size after initialisation\r\n    this.handleResize_();\r\n\r\n    for (let i = synchronizers.length - 1; i >= 0; --i) {\r\n      synchronizers[i].synchronize();\r\n    }\r\n\r\n    /**\r\n     * Time of the last rendered frame, as returned by `performance.now()`.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.lastFrameTime_ = 0;\r\n\r\n    /**\r\n     * The identifier returned by `requestAnimationFrame`.\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.renderId_ = undefined;\r\n\r\n    /**\r\n     * Target frame rate for the render loop.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.targetFrameRate_ = Number.POSITIVE_INFINITY;\r\n\r\n    /**\r\n     * If the Cesium render loop is being blocked.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.blockCesiumRendering_ = false;\r\n\r\n    /**\r\n     * If the warmup routine is active.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.warmingUp_ = false;\r\n\r\n    /**\r\n     * @type {ol.Feature}\r\n     * @private\r\n     */\r\n    this.trackedFeature_ = null;\r\n\r\n    /**\r\n     * @type {Cesium.Entity}\r\n     * @private\r\n     */\r\n    this.trackedEntity_ = null;\r\n\r\n    /**\r\n     * @type {Cesium.EntityView}\r\n     * @private\r\n     */\r\n    this.entityView_ = null;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.needTrackedEntityUpdate_ = false;\r\n\r\n    /**\r\n     * @type {!Cesium.BoundingSphere}\r\n     */\r\n    this.boundingSphereScratch_ = new Cesium.BoundingSphere();\r\n\r\n    const eventHelper = new Cesium.EventHelper();\r\n    eventHelper.add(this.scene_.postRender, OLCesium.prototype.updateTrackedEntity_, this);\r\n\r\n    // Cesium has a mechanism to prevent the camera to go under the terrain.\r\n    // Unfortunately, it is only active when all the terrain has been loaded, which:\r\n    // - does not prevent the camera to sink under terrain anymore;\r\n    // - introduce a jumping effect once all terrain has been loaded and the position of the camera is finally fixed.\r\n    // The property below enables a workaround found in the Camptocamp Cesium fork.\r\n    // See also https://github.com/AnalyticalGraphicsInc/cesium/issues/5999.\r\n    Cesium.Camera.enableSuspendTerrainAdjustment = false;\r\n  }\r\n\r\n  /**\r\n   * Render the Cesium scene.\r\n   * @private\r\n   */\r\n  render_() {\r\n    // if a call to `requestAnimationFrame` is pending, cancel it\r\n    if (this.renderId_ !== undefined) {\r\n      cancelAnimationFrame(this.renderId_);\r\n      this.renderId_ = undefined;\r\n    }\r\n\r\n    // only render if Cesium is enabled/warming and rendering hasn't been blocked\r\n    if ((this.enabled_ || this.warmingUp_) && !this.blockCesiumRendering_) {\r\n      this.renderId_ = requestAnimationFrame(this.onAnimationFrame_.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for `requestAnimationFrame`.\r\n   * @param {number} frameTime The frame time, from `performance.now()`.\r\n   * @private\r\n   */\r\n  onAnimationFrame_(frameTime) {\r\n    this.renderId_ = undefined;\r\n\r\n    // check if a frame was rendered within the target frame rate\r\n    const interval = 1000.0 / this.targetFrameRate_;\r\n    const delta = frameTime - this.lastFrameTime_;\r\n    if (delta < interval) {\r\n      // too soon, don't render yet\r\n      this.render_();\r\n      return;\r\n    }\r\n\r\n    // time to render a frame, save the time\r\n    this.lastFrameTime_ = frameTime;\r\n\r\n    const julianDate = this.time_();\r\n    this.scene_.initializeFrame();\r\n    this.handleResize_();\r\n    this.dataSourceDisplay_.update(julianDate);\r\n\r\n    // Update tracked entity\r\n    if (this.entityView_) {\r\n      const trackedEntity = this.trackedEntity_;\r\n      const trackedState = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);\r\n      if (trackedState === Cesium.BoundingSphereState.DONE) {\r\n        this.boundingSphereScratch_.radius = 1; // a radius of 1 is enough for tracking points\r\n        this.entityView_.update(julianDate, this.boundingSphereScratch_);\r\n      }\r\n    }\r\n\r\n    this.scene_.render(julianDate);\r\n    this.camera_.checkCameraChange();\r\n\r\n    // request the next render call after this one completes to ensure the browser doesn't get backed up\r\n    this.render_();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateTrackedEntity_() {\r\n    if (!this.needTrackedEntityUpdate_) {\r\n      return;\r\n    }\r\n\r\n    const trackedEntity = this.trackedEntity_;\r\n    const scene = this.scene_;\r\n\r\n    const state = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);\r\n    if (state === Cesium.BoundingSphereState.PENDING) {\r\n      return;\r\n    }\r\n\r\n    scene.screenSpaceCameraController.enableTilt = false;\r\n\r\n    const bs = state !== Cesium.BoundingSphereState.FAILED ? this.boundingSphereScratch_ : undefined;\r\n    if (bs) {\r\n      bs.radius = 1;\r\n    }\r\n    this.entityView_ = new Cesium.EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid);\r\n    this.entityView_.update(this.time_(), bs);\r\n    this.needTrackedEntityUpdate_ = false;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleResize_() {\r\n    let width = this.canvas_.clientWidth;\r\n    let height = this.canvas_.clientHeight;\r\n\r\n    if (width === 0 | height === 0) {\r\n      // The canvas DOM element is not ready yet.\r\n      return;\r\n    }\r\n\r\n    if (width === this.canvasClientWidth_ &&\r\n        height === this.canvasClientHeight_ &&\r\n        !this.resolutionScaleChanged_) {\r\n      return;\r\n    }\r\n\r\n    let resolutionScale = this.resolutionScale_;\r\n    if (!olcsUtil.supportsImageRenderingPixelated()) {\r\n      resolutionScale *= window.devicePixelRatio || 1.0;\r\n    }\r\n    this.resolutionScaleChanged_ = false;\r\n\r\n    this.canvasClientWidth_ = width;\r\n    this.canvasClientHeight_ = height;\r\n\r\n    width *= resolutionScale;\r\n    height *= resolutionScale;\r\n\r\n    this.canvas_.width = width;\r\n    this.canvas_.height = height;\r\n    this.scene_.camera.frustum.aspectRatio = width / height;\r\n  }\r\n\r\n  /**\r\n   * @return {!olcs.Camera}\r\n   * @api\r\n   */\r\n  getCamera() {\r\n    return this.camera_;\r\n  }\r\n\r\n  /**\r\n   * @return {!ol.Map}\r\n   * @api\r\n   */\r\n  getOlMap() {\r\n    return this.map_;\r\n  }\r\n\r\n  /**\r\n   * @return {!ol.View}\r\n   * @api\r\n   */\r\n  getOlView() {\r\n    const view = this.map_.getView();\r\n    console.assert(view);\r\n    return view;\r\n  }\r\n\r\n  /**\r\n   * @return {!Cesium.Scene}\r\n   * @api\r\n   */\r\n  getCesiumScene() {\r\n    return this.scene_;\r\n  }\r\n\r\n  /**\r\n   * @return {!Cesium.DataSourceCollection}\r\n   * @api\r\n   */\r\n  getDataSources() {\r\n    return this.dataSourceCollection_;\r\n  }\r\n\r\n  /**\r\n   * @return {!Cesium.DataSourceDisplay}\r\n   * @api\r\n   */\r\n  getDataSourceDisplay() {\r\n    return this.dataSourceDisplay_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean}\r\n   * @api\r\n   */\r\n  getEnabled() {\r\n    return this.enabled_;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables the Cesium.\r\n   * This modifies the visibility style of the container element.\r\n   * @param {boolean} enable\r\n   * @api\r\n   */\r\n  setEnabled(enable) {\r\n    if (this.enabled_ === enable) {\r\n      return;\r\n    }\r\n    this.enabled_ = enable;\r\n\r\n    // some Cesium operations are operating with canvas.clientWidth,\r\n    // so we can't remove it from DOM or even make display:none;\r\n    this.container_.style.visibility = this.enabled_ ? 'visible' : 'hidden';\r\n    let interactions;\r\n    if (this.enabled_) {\r\n      this.throwOnUnitializedMap_();\r\n      if (this.isOverMap_) {\r\n        interactions = this.map_.getInteractions();\r\n        interactions.forEach((el, i, arr) => {\r\n          this.pausedInteractions_.push(el);\r\n        });\r\n        interactions.clear();\r\n\r\n        this.map_.addInteraction = interaction => this.pausedInteractions_.push(interaction);\r\n        this.map_.removeInteraction = interaction =>\r\n          this.pausedInteractions_ = this.pausedInteractions_.filter(i => i !== interaction);\r\n\r\n        const rootGroup = this.map_.getLayerGroup();\r\n        if (rootGroup.getVisible()) {\r\n          this.hiddenRootGroup_ = rootGroup;\r\n          this.hiddenRootGroup_.setVisible(false);\r\n        }\r\n\r\n        this.map_.getOverlayContainer().classList.add('olcs-hideoverlay');\r\n        this.map_.getOverlayContainerStopEvent().classList.add('olcs-hideoverlay');\r\n      }\r\n\r\n      this.camera_.readFromView();\r\n      this.render_();\r\n    } else {\r\n      if (this.isOverMap_) {\r\n        interactions = this.map_.getInteractions();\r\n        this.pausedInteractions_.forEach((interaction) => {\r\n          interactions.push(interaction);\r\n        });\r\n        this.pausedInteractions_.length = 0;\r\n\r\n        this.map_.addInteraction = interaction => this.map_.getInteractions().push(interaction);\r\n        this.map_.removeInteraction = interaction => this.map_.getInteractions().remove(interaction);\r\n\r\n        this.map_.getOverlayContainer().classList.remove('olcs-hideoverlay');\r\n        this.map_.getOverlayContainerStopEvent().classList.remove('olcs-hideoverlay');\r\n        if (this.hiddenRootGroup_) {\r\n          this.hiddenRootGroup_.setVisible(true);\r\n          this.hiddenRootGroup_ = null;\r\n        }\r\n      }\r\n\r\n      this.camera_.updateView();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload Cesium so that it is ready when transitioning from 2D to 3D.\r\n   * @param {number} height Target height of the camera\r\n   * @param {number} timeout Milliseconds after which the warming will stop\r\n   * @api\r\n  */\r\n  warmUp(height, timeout) {\r\n    if (this.enabled_) {\r\n      // already enabled\r\n      return;\r\n    }\r\n    this.throwOnUnitializedMap_();\r\n    this.camera_.readFromView();\r\n    const ellipsoid = this.globe_.ellipsoid;\r\n    const csCamera = this.scene_.camera;\r\n    const position = ellipsoid.cartesianToCartographic(csCamera.position);\r\n    if (position.height < height) {\r\n      position.height = height;\r\n      csCamera.position = ellipsoid.cartographicToCartesian(position);\r\n    }\r\n\r\n    this.warmingUp_ = true;\r\n    this.render_();\r\n\r\n    setTimeout(() => {\r\n      this.warmingUp_ = false;\r\n    }, timeout);\r\n  }\r\n\r\n  /**\r\n   * Block Cesium rendering to save resources.\r\n   * @param {boolean} block True to block.\r\n   * @api\r\n  */\r\n  setBlockCesiumRendering(block) {\r\n    if (this.blockCesiumRendering_ !== block) {\r\n      this.blockCesiumRendering_ = block;\r\n\r\n      // reset the render loop\r\n      this.render_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render the globe only when necessary in order to save resources.\r\n   * Experimental.\r\n   * @api\r\n   */\r\n  enableAutoRenderLoop() {\r\n    if (!this.autoRenderLoop_) {\r\n      this.autoRenderLoop_ = new olcsAutoRenderLoop(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the autorender loop.\r\n   * @return {?olcs.AutoRenderLoop}\r\n   * @api\r\n  */\r\n  getAutoRenderLoop() {\r\n    return this.autoRenderLoop_;\r\n  }\r\n\r\n  /**\r\n   * The 3D Cesium globe is rendered in a canvas with two different dimensions:\r\n   * clientWidth and clientHeight which are the dimension on the screen and\r\n   * width and height which are the dimensions of the drawing buffer.\r\n   *\r\n   * By using a resolution scale lower than 1.0, it is possible to render the\r\n   * globe in a buffer smaller than the canvas client dimensions and improve\r\n   * performance, at the cost of quality.\r\n   *\r\n   * Pixel ratio should also be taken into account; by default, a device with\r\n   * pixel ratio of 2.0 will have a buffer surface 4 times bigger than the client\r\n   * surface.\r\n   *\r\n   * @param {number} value\r\n   * @this {olcs.OLCesium}\r\n   * @api\r\n   */\r\n  setResolutionScale(value) {\r\n    value = Math.max(0, value);\r\n    if (value !== this.resolutionScale_) {\r\n      this.resolutionScale_ = Math.max(0, value);\r\n      this.resolutionScaleChanged_ = true;\r\n      if (this.autoRenderLoop_) {\r\n        this.autoRenderLoop_.restartRenderLoop();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the target frame rate for the renderer. Set to `Number.POSITIVE_INFINITY`\r\n   * to render as quickly as possible.\r\n   * @param {number} value The frame rate, in frames per second.\r\n   * @api\r\n   */\r\n  setTargetFrameRate(value) {\r\n    if (this.targetFrameRate_ !== value) {\r\n      this.targetFrameRate_ = value;\r\n\r\n      // reset the render loop\r\n      this.render_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if OpenLayers map is not properly initialized.\r\n   * @private\r\n   */\r\n  throwOnUnitializedMap_() {\r\n    const map = this.map_;\r\n    const view = map.getView();\r\n    const center = view.getCenter();\r\n    if (!view.isDef() || isNaN(center[0]) || isNaN(center[1])) {\r\n      throw new Error(`The OpenLayers map is not properly initialized: ${center} / ${view.getResolution()}`);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nObject.defineProperties(OLCesium.prototype, {\r\n  'trackedFeature': {\r\n    'get': /** @this {olcs.OLCesium} */ function() {\r\n      return this.trackedFeature_;\r\n    },\r\n    'set': /** @this {olcs.OLCesium} */ function(feature) {\r\n      if (this.trackedFeature_ !== feature) {\r\n\r\n        const scene = this.scene_;\r\n\r\n        //Stop tracking\r\n        if (!feature || !feature.getGeometry()) {\r\n          this.needTrackedEntityUpdate_ = false;\r\n          scene.screenSpaceCameraController.enableTilt = true;\r\n\r\n          if (this.trackedEntity_) {\r\n            this.dataSourceDisplay_.defaultDataSource.entities.remove(this.trackedEntity_);\r\n          }\r\n          this.trackedEntity_ = null;\r\n          this.trackedFeature_ = null;\r\n          this.entityView_ = null;\r\n          scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);\r\n          return;\r\n        }\r\n\r\n        this.trackedFeature_ = feature;\r\n\r\n        //We can't start tracking immediately, so we set a flag and start tracking\r\n        //when the bounding sphere is ready (most likely next frame).\r\n        this.needTrackedEntityUpdate_ = true;\r\n\r\n        const to4326Transform = this.to4326Transform_;\r\n        const toCesiumPosition = function() {\r\n          const geometry = feature.getGeometry();\r\n          console.assert(geometry instanceof olGeomPoint);\r\n          const coo = geometry.getCoordinates();\r\n          const coo4326 = to4326Transform(coo, undefined, coo.length);\r\n          return olcsCore.ol4326CoordinateToCesiumCartesian(coo4326);\r\n        };\r\n\r\n        // Create an invisible point entity for tracking.\r\n        // It is independant from the primitive/geometry created by the vector synchronizer.\r\n        const options = {\r\n          'position': new Cesium.CallbackProperty((time, result) => toCesiumPosition(), false),\r\n          'point': {\r\n            'pixelSize': 1,\r\n            'color': Cesium.Color.TRANSPARENT\r\n          }\r\n        };\r\n\r\n        this.trackedEntity_ = this.dataSourceDisplay_.defaultDataSource.entities.add(options);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n\r\nexport default OLCesium;\r\n","/**\r\n * @module olcs.contrib.LazyLoader\r\n */\r\nconst exports = class {\r\n  /**\r\n   * @param {string} url\r\n   * @struct\r\n   * @api\r\n   */\r\n  constructor(url) {\r\n    /**\r\n     * @type {Promise<undefined>}\r\n     * @protected\r\n     */\r\n    this.promise;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.url_ = url;\r\n  }\r\n\r\n  /**\r\n   * @return {Promise<undefined>}\r\n   * @api\r\n   */\r\n  load() {\r\n    if (!this.promise) {\r\n      // not yet loading\r\n      this.promise = new Promise((resolve, reject) => {\r\n        const script = document.createElement('script');\r\n        script.onload = () => resolve();\r\n        script.onerror = () => reject();\r\n        document.head.appendChild(script);\r\n        script.src = this.url_;\r\n      });\r\n    }\r\n    return this.promise;\r\n  }\r\n};\r\n\r\n\r\nexport default exports;\r\n","/**\r\n * @module olcs.contrib.Manager\r\n */\r\nimport olcsContribLazyLoader from '../contrib/LazyLoader.js';\r\nimport OLCesium from '../OLCesium.js';\r\nimport olcsCore from '../core.js';\r\nimport {toRadians} from '../math.js';\r\nimport olObservable from 'ol/Observable.js';\r\n\r\n\r\n/**\r\n * @typedef {Object} ManagerOptions\r\n * @property {import('ol/Map.js').default} map\r\n * @property {import('ol/extent.js').Extent} [cameraExtentInRadians]\r\n */\r\n\r\n\r\nconst Manager = class extends olObservable {\r\n  /**\r\n   * @param {string} cesiumUrl\r\n   * @param {olcsx.contrib.ManagerOptions} options\r\n   * @api\r\n   */\r\n  constructor(cesiumUrl, {map, cameraExtentInRadians} = {}) {\r\n\r\n    super();\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.cesiumUrl_ = cesiumUrl;\r\n\r\n    /**\r\n     * @type {ol.Map}\r\n     * @protected\r\n     */\r\n    this.map = map;\r\n\r\n    /**\r\n     * @type {ol.Extent}\r\n     * @protected\r\n     */\r\n    this.cameraExtentInRadians = cameraExtentInRadians || null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Cesium.BoundingSphere}\r\n     */\r\n    this.boundingSphere_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.blockLimiter_ = false;\r\n\r\n    /**\r\n     * @type {Promise.<olcs.OLCesium>}\r\n     * @private\r\n     */\r\n    this.promise_;\r\n\r\n    /**\r\n     * @type {olcs.OLCesium}\r\n     * @protected\r\n     */\r\n    this.ol3d;\r\n\r\n\r\n    /**\r\n     * @const {number} Tilt angle in radians\r\n     * @private\r\n     */\r\n    this.cesiumInitialTilt_ = toRadians(50);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.fogDensity = 0.0001;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.fogSSEFactor = 25;\r\n\r\n    /**\r\n     * Limit the minimum distance to the terrain to 2m.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.minimumZoomDistance = 2;\r\n\r\n    /**\r\n     * Limit the maximum distance to the earth to 10'000km.\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.maximumZoomDistance = 10000000;\r\n\r\n    // when closer to 3000m, restrict the available positions harder\r\n    /**\r\n     * @protected\r\n     * @param {number} height\r\n     */\r\n    this.limitCameraToBoundingSphereRatio = height => (height > 3000 ? 9 : 3);\r\n  }\r\n\r\n\r\n  /**\r\n   * @return {Promise.<olcs.OLCesium>}\r\n   */\r\n  load() {\r\n    if (!this.promise_) {\r\n      const cesiumLazyLoader = new olcsContribLazyLoader(this.cesiumUrl_);\r\n      this.promise_ = cesiumLazyLoader.load().then(() => this.onCesiumLoaded());\r\n    }\r\n    return this.promise_;\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @return {olcs.OLCesium}\r\n   */\r\n  onCesiumLoaded() {\r\n    if (this.cameraExtentInRadians) {\r\n      const rect = new Cesium.Rectangle(...this.cameraExtentInRadians);\r\n      // Set the fly home rectangle\r\n      Cesium.Camera.DEFAULT_VIEW_RECTANGLE = rect;\r\n      this.boundingSphere_ = Cesium.BoundingSphere.fromRectangle3D(rect, Cesium.Ellipsoid.WGS84, 300); // lux mean height is 300m\r\n    }\r\n\r\n    this.ol3d = this.instantiateOLCesium();\r\n    const scene = this.ol3d.getCesiumScene();\r\n    this.configureForUsability(scene);\r\n    this.configureForPerformance(scene);\r\n    this.dispatchEvent('load');\r\n    return this.ol3d;\r\n  }\r\n\r\n\r\n  /**\r\n   * Application code should override this method.\r\n   * @return {olcs.OLCesium}\r\n   */\r\n  instantiateOLCesium() {\r\n    console.assert(this.map);\r\n    const ol3d = new OLCesium({map: this.map});\r\n    const scene = ol3d.getCesiumScene();\r\n    const terrainProvider = Cesium.createWorldTerrain();\r\n    scene.terrainProvider = terrainProvider;\r\n    return ol3d;\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {!Cesium.Scene} scene The scene, passed as parameter for convenience.\r\n   * @protected\r\n   */\r\n  configureForPerformance(scene) {\r\n    const fog = scene.fog;\r\n    fog.enabled = true;\r\n    fog.density = this.fogDensity;\r\n    fog.screenSpaceErrorFactor = this.fogSSEFactor;\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {!Cesium.Scene} scene The scene, passed as parameter for convenience.\r\n   * @protected\r\n   */\r\n  configureForUsability(scene) {\r\n    const sscController = scene.screenSpaceCameraController;\r\n    sscController.minimumZoomDistance = this.minimumZoomDistance;\r\n    sscController.maximumZoomDistance = this.maximumZoomDistance;\r\n\r\n    // Do not see through the terrain. Seeing through the terrain does not make\r\n    // sense anyway, except for debugging\r\n    scene.globe.depthTestAgainstTerrain = true;\r\n\r\n    // Use white instead of the black default colour for the globe when tiles are missing\r\n    scene.globe.baseColor = Cesium.Color.WHITE;\r\n    scene.backgroundColor = Cesium.Color.WHITE;\r\n\r\n    if (this.boundingSphere_) {\r\n      scene.postRender.addEventListener(this.limitCameraToBoundingSphere.bind(this), scene);\r\n    }\r\n    // Stop rendering Cesium when there is nothing to do. This drastically reduces CPU/GPU consumption.\r\n    this.ol3d.enableAutoRenderLoop();\r\n  }\r\n\r\n\r\n  /**\r\n   * Constrain the camera so that it stays close to the bounding sphere of the map extent.\r\n   * Near the ground the allowed distance is shorter.\r\n   * @protected\r\n   */\r\n  limitCameraToBoundingSphere() {\r\n    if (this.boundingSphere_ && !this.blockLimiter_) {\r\n      const scene = this.ol3d.getCesiumScene();\r\n      const camera = scene.camera;\r\n      const position = camera.position;\r\n      const carto = Cesium.Cartographic.fromCartesian(position);\r\n      const ratio = this.limitCameraToBoundingSphereRatio(carto.height);\r\n      if (Cesium.Cartesian3.distance(this.boundingSphere_.center, position) > this.boundingSphere_.radius * ratio) {\r\n        const currentlyFlying = camera.flying;\r\n        if (currentlyFlying === true) {\r\n          // There is a flying property and its value is true\r\n          return;\r\n        } else {\r\n          this.blockLimiter_ = true;\r\n          const unblockLimiter = () => this.blockLimiter_ = false;\r\n          camera.flyToBoundingSphere(this.boundingSphere_, {\r\n            complete: unblockLimiter,\r\n            cancel: unblockLimiter\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Enable or disable ol3d with a default animation.\r\n   * @export\r\n   * @return {Promise<undefined>}\r\n   */\r\n  toggle3d() {\r\n    return this.load().then((/** @const {!olcs.OLCesium} */ ol3d) => {\r\n      const is3DCurrentlyEnabled = ol3d.getEnabled();\r\n      const scene = ol3d.getCesiumScene();\r\n      if (is3DCurrentlyEnabled) {\r\n        // Disable 3D\r\n        console.assert(this.map);\r\n        return olcsCore.resetToNorthZenith(this.map, scene).then(() => {\r\n          ol3d.setEnabled(false);\r\n          this.dispatchEvent('toggle');\r\n        });\r\n      } else {\r\n        // Enable 3D\r\n        ol3d.setEnabled(true);\r\n        this.dispatchEvent('toggle');\r\n        return olcsCore.rotateAroundBottomCenter(scene, this.cesiumInitialTilt_);\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Enable ol3d with a view built from parameters.\r\n   *\r\n   * @export\r\n   * @param {number} lon\r\n   * @param {number} lat\r\n   * @param {number} elevation\r\n   * @param {number} headingDeg Heading value in degrees.\r\n   * @param {number} pitchDeg Pitch value in degrees.\r\n   * @returns {Promise<undefined>}\r\n   */\r\n  set3dWithView(lon, lat, elevation, headingDeg, pitchDeg) {\r\n    return this.load().then((/** @const {!olcs.OLCesium} */ ol3d) => {\r\n      const is3DCurrentlyEnabled = ol3d.getEnabled();\r\n      const scene = ol3d.getCesiumScene();\r\n      const camera = scene.camera;\r\n      const destination = Cesium.Cartesian3.fromDegrees(lon, lat, elevation);\r\n      const heading = Cesium.Math.toRadians(headingDeg);\r\n      const pitch = Cesium.Math.toRadians(pitchDeg);\r\n      const roll = 0;\r\n      const orientation = {heading, pitch, roll};\r\n\r\n      if (!is3DCurrentlyEnabled) {\r\n        ol3d.setEnabled(true);\r\n        this.dispatchEvent('toggle');\r\n      }\r\n\r\n      camera.setView({\r\n        destination,\r\n        orientation\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * @export\r\n   * @return {boolean}\r\n   */\r\n  is3dEnabled() {\r\n    return !!this.ol3d && this.ol3d.getEnabled();\r\n  }\r\n\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  getHeading() {\r\n    return this.map ? this.map.getView().getRotation() || 0 : 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * @return {number|undefined}\r\n   */\r\n  getTiltOnGlobe() {\r\n    const scene = this.ol3d.getCesiumScene();\r\n    const tiltOnGlobe = olcsCore.computeSignedTiltAngleOnGlobe(scene);\r\n    return -tiltOnGlobe;\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {number} angle\r\n   */\r\n  setHeading(angle) {\r\n    const scene = this.ol3d.getCesiumScene();\r\n    const bottom = olcsCore.pickBottomPoint(scene);\r\n    if (bottom) {\r\n      olcsCore.setHeadingUsingBottomCenter(scene, angle, bottom);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @return {olcs.OLCesium}\r\n   */\r\n  getOl3d() {\r\n    return this.ol3d;\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @return {!ol.View}\r\n   */\r\n  getOlView() {\r\n    const view = this.map.getView();\r\n    console.assert(view);\r\n    return view;\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @return {Cesium.Matrix4}\r\n   */\r\n  getCesiumViewMatrix() {\r\n    return this.ol3d.getCesiumScene().camera.viewMatrix;\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @return {!Cesium.Scene}\r\n   */\r\n  getCesiumScene() {\r\n    return this.ol3d.getCesiumScene();\r\n  }\r\n\r\n  /**\r\n   * @export\r\n   * @param {!Cesium.Rectangle} rectangle\r\n   * @param {number=} offset in meters\r\n   * @return {Promise<undefined>}\r\n   */\r\n  flyToRectangle(rectangle, offset = 0) {\r\n    const camera = this.getCesiumScene().camera;\r\n    const destination = camera.getRectangleCameraCoordinates(rectangle);\r\n\r\n    const mag = Cesium.Cartesian3.magnitude(destination) + offset;\r\n    Cesium.Cartesian3.normalize(destination, destination);\r\n    Cesium.Cartesian3.multiplyByScalar(destination, mag, destination);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.cameraExtentInRadians) {\r\n        reject();\r\n        return;\r\n      }\r\n\r\n      camera.flyTo({\r\n        destination,\r\n        complete: () => resolve(),\r\n        cancel: () => reject(),\r\n        endTransform: Cesium.Matrix4.IDENTITY\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @return {Cesium.Rectangle|undefined}\r\n   */\r\n  getCameraExtentRectangle() {\r\n    if (this.cameraExtentInRadians) {\r\n      return new Cesium.Rectangle(...this.cameraExtentInRadians);\r\n    }\r\n  }\r\n};\r\n\r\n\r\nexport default Manager;\r\n","import OLCesium from './olcs/OLCesium.js';\r\n\r\nimport AbstractSynchronizer from './olcs/AbstractSynchronizer.js';\r\nimport RasterSynchronizer from './olcs/RasterSynchronizer.js';\r\nimport VectorSynchronizer from './olcs/VectorSynchronizer.js';\r\n\r\nimport * as core from './olcs/core.js';\r\nimport OLImageryProvider from './olcs/core/OLImageryProvider.js';\r\nimport VectorLayerCounterpart from './olcs/core/VectorLayerCounterpart.js';\r\n\r\nimport LazyLoader from './olcs/contrib/LazyLoader.js';\r\nimport Manager from './olcs/contrib/Manager.js';\r\n\r\n\r\nexport default OLCesium;\r\n\r\n// Using var for phantomJS\r\n// eslint-disable-next-line no-var\r\nvar olcs = window['olcs'] = {};\r\nolcs.OLCesium = OLCesium;\r\n\r\nolcs.AbstractSynchronizer = AbstractSynchronizer;\r\nolcs.RasterSynchronizer = RasterSynchronizer;\r\nolcs.VectorSynchronizer = VectorSynchronizer;\r\n\r\nolcs.core = core.default;\r\nolcs.core.OLImageryProvider = OLImageryProvider;\r\nolcs.core.VectorLayerCounterpart = VectorLayerCounterpart;\r\n\r\nolcs.contrib = {};\r\nolcs.contrib.LazyLoader = LazyLoader;\r\nolcs.contrib.Manager = Manager;\r\n"],"sourceRoot":""}